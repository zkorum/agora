/* tslint:disable */
/* eslint-disable */
/**
 * Agora Citizen Network
 * Agora API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiV1AccountSubmitUsernameChangePostRequest
 */
export interface ApiV1AccountSubmitUsernameChangePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1AccountSubmitUsernameChangePostRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface ApiV1AuthAuthenticatePost200Response
 */
export interface ApiV1AuthAuthenticatePost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthAuthenticatePost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthAuthenticatePost200Response
     */
    'codeExpiry': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthAuthenticatePost200Response
     */
    'nextCodeSoonestTime': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthAuthenticatePost200Response
     */
    'reason': ApiV1AuthAuthenticatePost200ResponseReasonEnum;
}

export const ApiV1AuthAuthenticatePost200ResponseReasonEnum = {
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user',
    Throttled: 'throttled'
} as const;

export type ApiV1AuthAuthenticatePost200ResponseReasonEnum = typeof ApiV1AuthAuthenticatePost200ResponseReasonEnum[keyof typeof ApiV1AuthAuthenticatePost200ResponseReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1AuthAuthenticatePost200ResponseAnyOf
 */
export interface ApiV1AuthAuthenticatePost200ResponseAnyOf {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthAuthenticatePost200ResponseAnyOf
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthAuthenticatePost200ResponseAnyOf
     */
    'codeExpiry': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthAuthenticatePost200ResponseAnyOf
     */
    'nextCodeSoonestTime': string;
}
/**
 * 
 * @export
 * @interface ApiV1AuthAuthenticatePost200ResponseAnyOf1
 */
export interface ApiV1AuthAuthenticatePost200ResponseAnyOf1 {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthAuthenticatePost200ResponseAnyOf1
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthAuthenticatePost200ResponseAnyOf1
     */
    'reason': ApiV1AuthAuthenticatePost200ResponseAnyOf1ReasonEnum;
}

export const ApiV1AuthAuthenticatePost200ResponseAnyOf1ReasonEnum = {
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user',
    Throttled: 'throttled'
} as const;

export type ApiV1AuthAuthenticatePost200ResponseAnyOf1ReasonEnum = typeof ApiV1AuthAuthenticatePost200ResponseAnyOf1ReasonEnum[keyof typeof ApiV1AuthAuthenticatePost200ResponseAnyOf1ReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1AuthAuthenticatePostRequest
 */
export interface ApiV1AuthAuthenticatePostRequest {
    /**
     * Phone number
     * @type {string}
     * @memberof ApiV1AuthAuthenticatePostRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthAuthenticatePostRequest
     */
    'defaultCallingCode': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthAuthenticatePostRequest
     */
    'isRequestingNewCode': boolean;
}
/**
 * 
 * @export
 * @interface ApiV1AuthVerifyPhoneOtpPost200Response
 */
export interface ApiV1AuthVerifyPhoneOtpPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthVerifyPhoneOtpPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthVerifyPhoneOtpPost200Response
     */
    'reason': ApiV1AuthVerifyPhoneOtpPost200ResponseReasonEnum;
}

export const ApiV1AuthVerifyPhoneOtpPost200ResponseReasonEnum = {
    ExpiredCode: 'expired_code',
    WrongGuess: 'wrong_guess',
    TooManyWrongGuess: 'too_many_wrong_guess',
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user'
} as const;

export type ApiV1AuthVerifyPhoneOtpPost200ResponseReasonEnum = typeof ApiV1AuthVerifyPhoneOtpPost200ResponseReasonEnum[keyof typeof ApiV1AuthVerifyPhoneOtpPost200ResponseReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf
 */
export interface ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf1
 */
export interface ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf1 {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf1
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf1
     */
    'reason': ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf1ReasonEnum;
}

export const ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf1ReasonEnum = {
    ExpiredCode: 'expired_code',
    WrongGuess: 'wrong_guess',
    TooManyWrongGuess: 'too_many_wrong_guess',
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user'
} as const;

export type ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf1ReasonEnum = typeof ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf1ReasonEnum[keyof typeof ApiV1AuthVerifyPhoneOtpPost200ResponseAnyOf1ReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1AuthVerifyPhoneOtpPostRequest
 */
export interface ApiV1AuthVerifyPhoneOtpPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiV1AuthVerifyPhoneOtpPostRequest
     */
    'code': number;
}
/**
 * 
 * @export
 * @interface ApiV1AuthZkpGenerateVerificationLinkPost200Response
 */
export interface ApiV1AuthZkpGenerateVerificationLinkPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthZkpGenerateVerificationLinkPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthZkpGenerateVerificationLinkPost200Response
     */
    'verificationLink': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthZkpGenerateVerificationLinkPost200Response
     */
    'reason': ApiV1AuthZkpGenerateVerificationLinkPost200ResponseReasonEnum;
}

export const ApiV1AuthZkpGenerateVerificationLinkPost200ResponseReasonEnum = {
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user'
} as const;

export type ApiV1AuthZkpGenerateVerificationLinkPost200ResponseReasonEnum = typeof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseReasonEnum[keyof typeof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf
 */
export interface ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf
     */
    'verificationLink': string;
}
/**
 * 
 * @export
 * @interface ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf1
 */
export interface ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf1 {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf1
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf1
     */
    'reason': ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf1ReasonEnum;
}

export const ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf1ReasonEnum = {
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user'
} as const;

export type ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf1ReasonEnum = typeof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf1ReasonEnum[keyof typeof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseAnyOf1ReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response
 */
export interface ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response
     */
    'rarimoStatus': ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response
     */
    'reason': ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum;
}

export const ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum = {
    NotVerified: 'not_verified',
    Verified: 'verified',
    FailedVerification: 'failed_verification',
    UniquenessCheckFailed: 'uniqueness_check_failed'
} as const;

export type ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum = typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum[keyof typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum];
export const ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum = {
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user'
} as const;

export type ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum = typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum[keyof typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf
 */
export interface ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf
     */
    'rarimoStatus': ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum;
}

export const ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum = {
    NotVerified: 'not_verified',
    Verified: 'verified',
    FailedVerification: 'failed_verification',
    UniquenessCheckFailed: 'uniqueness_check_failed'
} as const;

export type ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum = typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum[keyof typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum];

/**
 * 
 * @export
 * @interface ApiV1CommentCreatePost200Response
 */
export interface ApiV1CommentCreatePost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1CommentCreatePost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentCreatePost200Response
     */
    'commentSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentCreatePost200Response
     */
    'reason': ApiV1CommentCreatePost200ResponseReasonEnum;
}

export const ApiV1CommentCreatePost200ResponseReasonEnum = {
    PostLocked: 'post_locked'
} as const;

export type ApiV1CommentCreatePost200ResponseReasonEnum = typeof ApiV1CommentCreatePost200ResponseReasonEnum[keyof typeof ApiV1CommentCreatePost200ResponseReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1CommentCreatePost200ResponseAnyOf
 */
export interface ApiV1CommentCreatePost200ResponseAnyOf {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1CommentCreatePost200ResponseAnyOf
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentCreatePost200ResponseAnyOf
     */
    'commentSlugId': string;
}
/**
 * 
 * @export
 * @interface ApiV1CommentCreatePost200ResponseAnyOf1
 */
export interface ApiV1CommentCreatePost200ResponseAnyOf1 {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1CommentCreatePost200ResponseAnyOf1
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentCreatePost200ResponseAnyOf1
     */
    'reason': ApiV1CommentCreatePost200ResponseAnyOf1ReasonEnum;
}

export const ApiV1CommentCreatePost200ResponseAnyOf1ReasonEnum = {
    PostLocked: 'post_locked'
} as const;

export type ApiV1CommentCreatePost200ResponseAnyOf1ReasonEnum = typeof ApiV1CommentCreatePost200ResponseAnyOf1ReasonEnum[keyof typeof ApiV1CommentCreatePost200ResponseAnyOf1ReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1CommentCreatePostRequest
 */
export interface ApiV1CommentCreatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentCreatePostRequest
     */
    'postSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentCreatePostRequest
     */
    'commentBody': string;
}
/**
 * 
 * @export
 * @interface ApiV1CommentFetchCommentsByPostSlugIdPostRequest
 */
export interface ApiV1CommentFetchCommentsByPostSlugIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentFetchCommentsByPostSlugIdPostRequest
     */
    'postSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentFetchCommentsByPostSlugIdPostRequest
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentFetchCommentsByPostSlugIdPostRequest
     */
    'filter': ApiV1CommentFetchCommentsByPostSlugIdPostRequestFilterEnum;
}

export const ApiV1CommentFetchCommentsByPostSlugIdPostRequestFilterEnum = {
    Moderated: 'moderated',
    New: 'new'
} as const;

export type ApiV1CommentFetchCommentsByPostSlugIdPostRequestFilterEnum = typeof ApiV1CommentFetchCommentsByPostSlugIdPostRequestFilterEnum[keyof typeof ApiV1CommentFetchCommentsByPostSlugIdPostRequestFilterEnum];

/**
 * 
 * @export
 * @interface ApiV1CommentFetchHiddenCommentsPostRequest
 */
export interface ApiV1CommentFetchHiddenCommentsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentFetchHiddenCommentsPostRequest
     */
    'postSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1CommentFetchHiddenCommentsPostRequest
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPost200Response
 */
export interface ApiV1FeedFetchRecentPost200Response {
    /**
     * 
     * @type {Array<ApiV1FeedFetchRecentPost200ResponsePostDataListInner>}
     * @memberof ApiV1FeedFetchRecentPost200Response
     */
    'postDataList': Array<ApiV1FeedFetchRecentPost200ResponsePostDataListInner>;
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1FeedFetchRecentPost200Response
     */
    'reachedEndOfFeed': boolean;
}
/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPost200ResponsePostDataListInner
 */
export interface ApiV1FeedFetchRecentPost200ResponsePostDataListInner {
    /**
     * 
     * @type {ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInner
     */
    'metadata': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata;
    /**
     * 
     * @type {ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayload}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInner
     */
    'payload': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayload;
    /**
     * 
     * @type {ApiV1FeedFetchRecentPost200ResponsePostDataListInnerInteraction}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInner
     */
    'interaction': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerInteraction;
}
/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerInteraction
 */
export interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerInteraction {
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerInteraction
     */
    'hasVoted': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerInteraction
     */
    'votedIndex': number;
}
/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata
 */
export interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata
     */
    'postSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata
     */
    'lastReactedAt': string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata
     */
    'commentCount': number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata
     */
    'authorUsername': string;
    /**
     * 
     * @type {ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadata
     */
    'moderation': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration;
}
/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration
 */
export interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration {
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration
     */
    'status': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration
     */
    'action': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationActionEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration
     */
    'reason': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration
     */
    'explanation': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration
     */
    'updatedAt': string;
}

export const ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationStatusEnum = {
    Unmoderated: 'unmoderated'
} as const;

export type ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationStatusEnum = typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationStatusEnum[keyof typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationStatusEnum];
export const ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationActionEnum = {
    Lock: 'lock'
} as const;

export type ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationActionEnum = typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationActionEnum[keyof typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationActionEnum];
export const ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationReasonEnum = typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationReasonEnum[keyof typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf
 */
export interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf {
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf
     */
    'status': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf
     */
    'action': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfActionEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf
     */
    'reason': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf
     */
    'explanation': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf
     */
    'updatedAt': string;
}

export const ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfStatusEnum = {
    Moderated: 'moderated'
} as const;

export type ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfStatusEnum = typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfStatusEnum[keyof typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfStatusEnum];
export const ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfActionEnum = {
    Lock: 'lock'
} as const;

export type ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfActionEnum = typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfActionEnum[keyof typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfActionEnum];
export const ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfReasonEnum = typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfReasonEnum[keyof typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOfReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf1
 */
export interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf1
     */
    'status': ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf1StatusEnum;
}

export const ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf1StatusEnum = {
    Unmoderated: 'unmoderated'
} as const;

export type ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf1StatusEnum = typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf1StatusEnum[keyof typeof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModerationAnyOf1StatusEnum];

/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayload
 */
export interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayload {
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayload
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayload
     */
    'body'?: string;
    /**
     * 
     * @type {Array<ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayloadPollInner>}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayload
     */
    'poll'?: Array<ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayloadPollInner>;
}
/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayloadPollInner
 */
export interface ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayloadPollInner {
    /**
     * 
     * @type {number}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayloadPollInner
     */
    'optionNumber': number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayloadPollInner
     */
    'optionTitle': string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1FeedFetchRecentPost200ResponsePostDataListInnerPayloadPollInner
     */
    'numResponses': number;
}
/**
 * 
 * @export
 * @interface ApiV1FeedFetchRecentPostRequest
 */
export interface ApiV1FeedFetchRecentPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1FeedFetchRecentPostRequest
     */
    'lastSlugId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1FeedFetchRecentPostRequest
     */
    'isAuthenticatedRequest': boolean;
}
/**
 * 
 * @export
 * @interface ApiV1ModerationCommentCreatePostRequest
 */
export interface ApiV1ModerationCommentCreatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentCreatePostRequest
     */
    'commentSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentCreatePostRequest
     */
    'moderationReason': ApiV1ModerationCommentCreatePostRequestModerationReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentCreatePostRequest
     */
    'moderationAction': ApiV1ModerationCommentCreatePostRequestModerationActionEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentCreatePostRequest
     */
    'moderationExplanation': string;
}

export const ApiV1ModerationCommentCreatePostRequestModerationReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ModerationCommentCreatePostRequestModerationReasonEnum = typeof ApiV1ModerationCommentCreatePostRequestModerationReasonEnum[keyof typeof ApiV1ModerationCommentCreatePostRequestModerationReasonEnum];
export const ApiV1ModerationCommentCreatePostRequestModerationActionEnum = {
    Lock: 'lock',
    Hide: 'hide'
} as const;

export type ApiV1ModerationCommentCreatePostRequestModerationActionEnum = typeof ApiV1ModerationCommentCreatePostRequestModerationActionEnum[keyof typeof ApiV1ModerationCommentCreatePostRequestModerationActionEnum];

/**
 * 
 * @export
 * @interface ApiV1ModerationCommentFetchReportPost200Response
 */
export interface ApiV1ModerationCommentFetchReportPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200Response
     */
    'status': ApiV1ModerationCommentFetchReportPost200ResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200Response
     */
    'action': ApiV1ModerationCommentFetchReportPost200ResponseActionEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200Response
     */
    'reason': ApiV1ModerationCommentFetchReportPost200ResponseReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200Response
     */
    'explanation': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200Response
     */
    'updatedAt': string;
}

export const ApiV1ModerationCommentFetchReportPost200ResponseStatusEnum = {
    Unmoderated: 'unmoderated'
} as const;

export type ApiV1ModerationCommentFetchReportPost200ResponseStatusEnum = typeof ApiV1ModerationCommentFetchReportPost200ResponseStatusEnum[keyof typeof ApiV1ModerationCommentFetchReportPost200ResponseStatusEnum];
export const ApiV1ModerationCommentFetchReportPost200ResponseActionEnum = {
    Lock: 'lock',
    Hide: 'hide'
} as const;

export type ApiV1ModerationCommentFetchReportPost200ResponseActionEnum = typeof ApiV1ModerationCommentFetchReportPost200ResponseActionEnum[keyof typeof ApiV1ModerationCommentFetchReportPost200ResponseActionEnum];
export const ApiV1ModerationCommentFetchReportPost200ResponseReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ModerationCommentFetchReportPost200ResponseReasonEnum = typeof ApiV1ModerationCommentFetchReportPost200ResponseReasonEnum[keyof typeof ApiV1ModerationCommentFetchReportPost200ResponseReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1ModerationCommentFetchReportPost200ResponseAnyOf
 */
export interface ApiV1ModerationCommentFetchReportPost200ResponseAnyOf {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200ResponseAnyOf
     */
    'status': ApiV1ModerationCommentFetchReportPost200ResponseAnyOfStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200ResponseAnyOf
     */
    'action': ApiV1ModerationCommentFetchReportPost200ResponseAnyOfActionEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200ResponseAnyOf
     */
    'reason': ApiV1ModerationCommentFetchReportPost200ResponseAnyOfReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200ResponseAnyOf
     */
    'explanation': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200ResponseAnyOf
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentFetchReportPost200ResponseAnyOf
     */
    'updatedAt': string;
}

export const ApiV1ModerationCommentFetchReportPost200ResponseAnyOfStatusEnum = {
    Moderated: 'moderated'
} as const;

export type ApiV1ModerationCommentFetchReportPost200ResponseAnyOfStatusEnum = typeof ApiV1ModerationCommentFetchReportPost200ResponseAnyOfStatusEnum[keyof typeof ApiV1ModerationCommentFetchReportPost200ResponseAnyOfStatusEnum];
export const ApiV1ModerationCommentFetchReportPost200ResponseAnyOfActionEnum = {
    Lock: 'lock',
    Hide: 'hide'
} as const;

export type ApiV1ModerationCommentFetchReportPost200ResponseAnyOfActionEnum = typeof ApiV1ModerationCommentFetchReportPost200ResponseAnyOfActionEnum[keyof typeof ApiV1ModerationCommentFetchReportPost200ResponseAnyOfActionEnum];
export const ApiV1ModerationCommentFetchReportPost200ResponseAnyOfReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ModerationCommentFetchReportPost200ResponseAnyOfReasonEnum = typeof ApiV1ModerationCommentFetchReportPost200ResponseAnyOfReasonEnum[keyof typeof ApiV1ModerationCommentFetchReportPost200ResponseAnyOfReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1ModerationCommentWithdrawPostRequest
 */
export interface ApiV1ModerationCommentWithdrawPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationCommentWithdrawPostRequest
     */
    'commentSlugId': string;
}
/**
 * 
 * @export
 * @interface ApiV1ModerationPostCreatePostRequest
 */
export interface ApiV1ModerationPostCreatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationPostCreatePostRequest
     */
    'postSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationPostCreatePostRequest
     */
    'moderationReason': ApiV1ModerationPostCreatePostRequestModerationReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationPostCreatePostRequest
     */
    'moderationAction': ApiV1ModerationPostCreatePostRequestModerationActionEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationPostCreatePostRequest
     */
    'moderationExplanation': string;
}

export const ApiV1ModerationPostCreatePostRequestModerationReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ModerationPostCreatePostRequestModerationReasonEnum = typeof ApiV1ModerationPostCreatePostRequestModerationReasonEnum[keyof typeof ApiV1ModerationPostCreatePostRequestModerationReasonEnum];
export const ApiV1ModerationPostCreatePostRequestModerationActionEnum = {
    Lock: 'lock'
} as const;

export type ApiV1ModerationPostCreatePostRequestModerationActionEnum = typeof ApiV1ModerationPostCreatePostRequestModerationActionEnum[keyof typeof ApiV1ModerationPostCreatePostRequestModerationActionEnum];

/**
 * 
 * @export
 * @interface ApiV1ModerationPostWithdrawPostRequest
 */
export interface ApiV1ModerationPostWithdrawPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ModerationPostWithdrawPostRequest
     */
    'postSlugId': string;
}
/**
 * 
 * @export
 * @interface ApiV1PollGetUserPollResponsePost200ResponseInner
 */
export interface ApiV1PollGetUserPollResponsePost200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1PollGetUserPollResponsePost200ResponseInner
     */
    'postSlugId': string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1PollGetUserPollResponsePost200ResponseInner
     */
    'optionChosen': number;
}
/**
 * 
 * @export
 * @interface ApiV1PollSubmitResponsePostRequest
 */
export interface ApiV1PollSubmitResponsePostRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiV1PollSubmitResponsePostRequest
     */
    'voteOptionChoice': number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1PollSubmitResponsePostRequest
     */
    'postSlugId': string;
}
/**
 * 
 * @export
 * @interface ApiV1PostCreatePost200Response
 */
export interface ApiV1PostCreatePost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1PostCreatePost200Response
     */
    'postSlugId': string;
}
/**
 * 
 * @export
 * @interface ApiV1PostCreatePostRequest
 */
export interface ApiV1PostCreatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1PostCreatePostRequest
     */
    'postTitle': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1PostCreatePostRequest
     */
    'postBody'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1PostCreatePostRequest
     */
    'pollingOptionList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiV1PostFetchPostBySlugIdPost200Response
 */
export interface ApiV1PostFetchPostBySlugIdPost200Response {
    /**
     * 
     * @type {ApiV1FeedFetchRecentPost200ResponsePostDataListInner}
     * @memberof ApiV1PostFetchPostBySlugIdPost200Response
     */
    'postData': ApiV1FeedFetchRecentPost200ResponsePostDataListInner;
}
/**
 * 
 * @export
 * @interface ApiV1PostFetchPostBySlugIdPostRequest
 */
export interface ApiV1PostFetchPostBySlugIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1PostFetchPostBySlugIdPostRequest
     */
    'postSlugId': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1PostFetchPostBySlugIdPostRequest
     */
    'isAuthenticatedRequest': boolean;
}
/**
 * 
 * @export
 * @interface ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner
 */
export interface ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner
     */
    'reason': ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInnerReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner
     */
    'explanation'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner
     */
    'id': number;
}

export const ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInnerReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInnerReasonEnum = typeof ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInnerReasonEnum[keyof typeof ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInnerReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1ReportSubmitReportByCommentSlugIdPostRequest
 */
export interface ApiV1ReportSubmitReportByCommentSlugIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportSubmitReportByCommentSlugIdPostRequest
     */
    'commentSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportSubmitReportByCommentSlugIdPostRequest
     */
    'reportReason': ApiV1ReportSubmitReportByCommentSlugIdPostRequestReportReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportSubmitReportByCommentSlugIdPostRequest
     */
    'reportExplanation'?: string;
}

export const ApiV1ReportSubmitReportByCommentSlugIdPostRequestReportReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ReportSubmitReportByCommentSlugIdPostRequestReportReasonEnum = typeof ApiV1ReportSubmitReportByCommentSlugIdPostRequestReportReasonEnum[keyof typeof ApiV1ReportSubmitReportByCommentSlugIdPostRequestReportReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1ReportSubmitReportByPostSlugIdPostRequest
 */
export interface ApiV1ReportSubmitReportByPostSlugIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportSubmitReportByPostSlugIdPostRequest
     */
    'postSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportSubmitReportByPostSlugIdPostRequest
     */
    'reportReason': ApiV1ReportSubmitReportByPostSlugIdPostRequestReportReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiV1ReportSubmitReportByPostSlugIdPostRequest
     */
    'reportExplanation'?: string;
}

export const ApiV1ReportSubmitReportByPostSlugIdPostRequestReportReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ReportSubmitReportByPostSlugIdPostRequestReportReasonEnum = typeof ApiV1ReportSubmitReportByPostSlugIdPostRequestReportReasonEnum[keyof typeof ApiV1ReportSubmitReportByPostSlugIdPostRequestReportReasonEnum];

/**
 * 
 * @export
 * @interface ApiV1UserFetchUserCommentsPost200ResponseInner
 */
export interface ApiV1UserFetchUserCommentsPost200ResponseInner {
    /**
     * 
     * @type {ApiV1FeedFetchRecentPost200ResponsePostDataListInner}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInner
     */
    'postData': ApiV1FeedFetchRecentPost200ResponsePostDataListInner;
    /**
     * 
     * @type {ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInner
     */
    'commentItem': ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem;
}
/**
 * 
 * @export
 * @interface ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem
 */
export interface ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem
     */
    'commentSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem
     */
    'comment': string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem
     */
    'numLikes': number;
    /**
     * 
     * @type {number}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem
     */
    'numDislikes': number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem
     */
    'username': string;
    /**
     * 
     * @type {ApiV1ModerationCommentFetchReportPost200Response}
     * @memberof ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem
     */
    'moderation': ApiV1ModerationCommentFetchReportPost200Response;
}
/**
 * 
 * @export
 * @interface ApiV1UserFetchUserCommentsPostRequest
 */
export interface ApiV1UserFetchUserCommentsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserFetchUserCommentsPostRequest
     */
    'lastCommentSlugId'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UserFetchUserPostsPostRequest
 */
export interface ApiV1UserFetchUserPostsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserFetchUserPostsPostRequest
     */
    'lastPostSlugId'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UserFetchUserProfilePost200Response
 */
export interface ApiV1UserFetchUserProfilePost200Response {
    /**
     * 
     * @type {number}
     * @memberof ApiV1UserFetchUserProfilePost200Response
     */
    'activePostCount': number;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserFetchUserProfilePost200Response
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserFetchUserProfilePost200Response
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiV1UserFetchUserProfilePost200Response
     */
    'isModerator': boolean;
}
/**
 * 
 * @export
 * @interface ApiV1UserMuteMuteUserPostRequest
 */
export interface ApiV1UserMuteMuteUserPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserMuteMuteUserPostRequest
     */
    'targetUsername': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UserMuteMuteUserPostRequest
     */
    'action': ApiV1UserMuteMuteUserPostRequestActionEnum;
}

export const ApiV1UserMuteMuteUserPostRequestActionEnum = {
    Mute: 'mute',
    Unmute: 'unmute'
} as const;

export type ApiV1UserMuteMuteUserPostRequestActionEnum = typeof ApiV1UserMuteMuteUserPostRequestActionEnum[keyof typeof ApiV1UserMuteMuteUserPostRequestActionEnum];

/**
 * 
 * @export
 * @interface ApiV1VotingCastVotePostRequest
 */
export interface ApiV1VotingCastVotePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VotingCastVotePostRequest
     */
    'commentSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1VotingCastVotePostRequest
     */
    'chosenOption': ApiV1VotingCastVotePostRequestChosenOptionEnum;
}

export const ApiV1VotingCastVotePostRequestChosenOptionEnum = {
    Like: 'like',
    Dislike: 'dislike',
    Cancel: 'cancel'
} as const;

export type ApiV1VotingCastVotePostRequestChosenOptionEnum = typeof ApiV1VotingCastVotePostRequestChosenOptionEnum[keyof typeof ApiV1VotingCastVotePostRequestChosenOptionEnum];

/**
 * 
 * @export
 * @interface ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInner
 */
export interface ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInner
     */
    'commentSlugId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInner
     */
    'votingAction': ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInnerVotingActionEnum;
}

export const ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInnerVotingActionEnum = {
    Like: 'like',
    Dislike: 'dislike'
} as const;

export type ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInnerVotingActionEnum = typeof ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInnerVotingActionEnum[keyof typeof ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInnerVotingActionEnum];

/**
 * 
 * @export
 * @interface ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest
 */
export interface ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest
     */
    'postSlugIdList': Array<string>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountDeleteUserPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/delete-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountGenerateUnusedRandomUsernamePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/generate-unused-random-username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AccountSubmitUsernameChangePostRequest} apiV1AccountSubmitUsernameChangePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountIsUsernameInUsePost: async (apiV1AccountSubmitUsernameChangePostRequest: ApiV1AccountSubmitUsernameChangePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AccountSubmitUsernameChangePostRequest' is not null or undefined
            assertParamExists('apiV1AccountIsUsernameInUsePost', 'apiV1AccountSubmitUsernameChangePostRequest', apiV1AccountSubmitUsernameChangePostRequest)
            const localVarPath = `/api/v1/account/is-username-in-use`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AccountSubmitUsernameChangePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AccountSubmitUsernameChangePostRequest} apiV1AccountSubmitUsernameChangePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountSubmitUsernameChangePost: async (apiV1AccountSubmitUsernameChangePostRequest: ApiV1AccountSubmitUsernameChangePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AccountSubmitUsernameChangePostRequest' is not null or undefined
            assertParamExists('apiV1AccountSubmitUsernameChangePost', 'apiV1AccountSubmitUsernameChangePostRequest', apiV1AccountSubmitUsernameChangePostRequest)
            const localVarPath = `/api/v1/account/submit-username-change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AccountSubmitUsernameChangePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AuthAuthenticatePostRequest} apiV1AuthAuthenticatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAuthenticatePost: async (apiV1AuthAuthenticatePostRequest: ApiV1AuthAuthenticatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AuthAuthenticatePostRequest' is not null or undefined
            assertParamExists('apiV1AuthAuthenticatePost', 'apiV1AuthAuthenticatePostRequest', apiV1AuthAuthenticatePostRequest)
            const localVarPath = `/api/v1/auth/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AuthAuthenticatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthCheckLoginStatusPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/check-login-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AuthVerifyPhoneOtpPostRequest} apiV1AuthVerifyPhoneOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthVerifyPhoneOtpPost: async (apiV1AuthVerifyPhoneOtpPostRequest: ApiV1AuthVerifyPhoneOtpPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AuthVerifyPhoneOtpPostRequest' is not null or undefined
            assertParamExists('apiV1AuthVerifyPhoneOtpPost', 'apiV1AuthVerifyPhoneOtpPostRequest', apiV1AuthVerifyPhoneOtpPostRequest)
            const localVarPath = `/api/v1/auth/verify-phone-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AuthVerifyPhoneOtpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthZkpGenerateVerificationLinkPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/zkp/generate-verification-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthZkpVerifyUserStatusAndAuthenticatePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/zkp/verify-user-status-and-authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1CommentCreatePostRequest} apiV1CommentCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CommentCreatePost: async (apiV1CommentCreatePostRequest: ApiV1CommentCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1CommentCreatePostRequest' is not null or undefined
            assertParamExists('apiV1CommentCreatePost', 'apiV1CommentCreatePostRequest', apiV1CommentCreatePostRequest)
            const localVarPath = `/api/v1/comment/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1CommentCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CommentDeletePost: async (apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationCommentWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1CommentDeletePost', 'apiV1ModerationCommentWithdrawPostRequest', apiV1ModerationCommentWithdrawPostRequest)
            const localVarPath = `/api/v1/comment/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationCommentWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1CommentFetchCommentsByPostSlugIdPostRequest} apiV1CommentFetchCommentsByPostSlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CommentFetchCommentsByPostSlugIdPost: async (apiV1CommentFetchCommentsByPostSlugIdPostRequest: ApiV1CommentFetchCommentsByPostSlugIdPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1CommentFetchCommentsByPostSlugIdPostRequest' is not null or undefined
            assertParamExists('apiV1CommentFetchCommentsByPostSlugIdPost', 'apiV1CommentFetchCommentsByPostSlugIdPostRequest', apiV1CommentFetchCommentsByPostSlugIdPostRequest)
            const localVarPath = `/api/v1/comment/fetch-comments-by-post-slugId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1CommentFetchCommentsByPostSlugIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1CommentFetchHiddenCommentsPostRequest} apiV1CommentFetchHiddenCommentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CommentFetchHiddenCommentsPost: async (apiV1CommentFetchHiddenCommentsPostRequest: ApiV1CommentFetchHiddenCommentsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1CommentFetchHiddenCommentsPostRequest' is not null or undefined
            assertParamExists('apiV1CommentFetchHiddenCommentsPost', 'apiV1CommentFetchHiddenCommentsPostRequest', apiV1CommentFetchHiddenCommentsPostRequest)
            const localVarPath = `/api/v1/comment/fetch-hidden-comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1CommentFetchHiddenCommentsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1FeedFetchRecentPostRequest} apiV1FeedFetchRecentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedFetchRecentPost: async (apiV1FeedFetchRecentPostRequest: ApiV1FeedFetchRecentPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1FeedFetchRecentPostRequest' is not null or undefined
            assertParamExists('apiV1FeedFetchRecentPost', 'apiV1FeedFetchRecentPostRequest', apiV1FeedFetchRecentPostRequest)
            const localVarPath = `/api/v1/feed/fetch-recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1FeedFetchRecentPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationCommentCreatePostRequest} apiV1ModerationCommentCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationCommentCreatePost: async (apiV1ModerationCommentCreatePostRequest: ApiV1ModerationCommentCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationCommentCreatePostRequest' is not null or undefined
            assertParamExists('apiV1ModerationCommentCreatePost', 'apiV1ModerationCommentCreatePostRequest', apiV1ModerationCommentCreatePostRequest)
            const localVarPath = `/api/v1/moderation/comment/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationCommentCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationCommentFetchReportPost: async (apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationCommentWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ModerationCommentFetchReportPost', 'apiV1ModerationCommentWithdrawPostRequest', apiV1ModerationCommentWithdrawPostRequest)
            const localVarPath = `/api/v1/moderation/comment/fetch-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationCommentWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationCommentWithdrawPost: async (apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationCommentWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ModerationCommentWithdrawPost', 'apiV1ModerationCommentWithdrawPostRequest', apiV1ModerationCommentWithdrawPostRequest)
            const localVarPath = `/api/v1/moderation/comment/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationCommentWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationPostCreatePostRequest} apiV1ModerationPostCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationPostCreatePost: async (apiV1ModerationPostCreatePostRequest: ApiV1ModerationPostCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationPostCreatePostRequest' is not null or undefined
            assertParamExists('apiV1ModerationPostCreatePost', 'apiV1ModerationPostCreatePostRequest', apiV1ModerationPostCreatePostRequest)
            const localVarPath = `/api/v1/moderation/post/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationPostCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationPostFetchReportPost: async (apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationPostWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ModerationPostFetchReportPost', 'apiV1ModerationPostWithdrawPostRequest', apiV1ModerationPostWithdrawPostRequest)
            const localVarPath = `/api/v1/moderation/post/fetch-report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationPostWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationPostWithdrawPost: async (apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationPostWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ModerationPostWithdrawPost', 'apiV1ModerationPostWithdrawPostRequest', apiV1ModerationPostWithdrawPostRequest)
            const localVarPath = `/api/v1/moderation/post/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationPostWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PollGetUserPollResponsePost: async (requestBody?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/poll/get-user-poll-response`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PollSubmitResponsePostRequest} apiV1PollSubmitResponsePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PollSubmitResponsePost: async (apiV1PollSubmitResponsePostRequest: ApiV1PollSubmitResponsePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1PollSubmitResponsePostRequest' is not null or undefined
            assertParamExists('apiV1PollSubmitResponsePost', 'apiV1PollSubmitResponsePostRequest', apiV1PollSubmitResponsePostRequest)
            const localVarPath = `/api/v1/poll/submitResponse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1PollSubmitResponsePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PostCreatePostRequest} apiV1PostCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PostCreatePost: async (apiV1PostCreatePostRequest: ApiV1PostCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1PostCreatePostRequest' is not null or undefined
            assertParamExists('apiV1PostCreatePost', 'apiV1PostCreatePostRequest', apiV1PostCreatePostRequest)
            const localVarPath = `/api/v1/post/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1PostCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PostDeletePost: async (apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationPostWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1PostDeletePost', 'apiV1ModerationPostWithdrawPostRequest', apiV1ModerationPostWithdrawPostRequest)
            const localVarPath = `/api/v1/post/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationPostWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PostFetchPostBySlugIdPostRequest} apiV1PostFetchPostBySlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PostFetchPostBySlugIdPost: async (apiV1PostFetchPostBySlugIdPostRequest: ApiV1PostFetchPostBySlugIdPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1PostFetchPostBySlugIdPostRequest' is not null or undefined
            assertParamExists('apiV1PostFetchPostBySlugIdPost', 'apiV1PostFetchPostBySlugIdPostRequest', apiV1PostFetchPostBySlugIdPostRequest)
            const localVarPath = `/api/v1/post/fetch-post-by-slug-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1PostFetchPostBySlugIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportFetchReportsByCommentSlugIdPost: async (apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationCommentWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ReportFetchReportsByCommentSlugIdPost', 'apiV1ModerationCommentWithdrawPostRequest', apiV1ModerationCommentWithdrawPostRequest)
            const localVarPath = `/api/v1/report/fetch-reports-by-comment-slug-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationCommentWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportFetchReportsByPostSlugIdPost: async (apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationPostWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ReportFetchReportsByPostSlugIdPost', 'apiV1ModerationPostWithdrawPostRequest', apiV1ModerationPostWithdrawPostRequest)
            const localVarPath = `/api/v1/report/fetch-reports-by-post-slug-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationPostWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ReportSubmitReportByCommentSlugIdPostRequest} apiV1ReportSubmitReportByCommentSlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportSubmitReportByCommentSlugIdPost: async (apiV1ReportSubmitReportByCommentSlugIdPostRequest: ApiV1ReportSubmitReportByCommentSlugIdPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ReportSubmitReportByCommentSlugIdPostRequest' is not null or undefined
            assertParamExists('apiV1ReportSubmitReportByCommentSlugIdPost', 'apiV1ReportSubmitReportByCommentSlugIdPostRequest', apiV1ReportSubmitReportByCommentSlugIdPostRequest)
            const localVarPath = `/api/v1/report/submit-report-by-comment-slug-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ReportSubmitReportByCommentSlugIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ReportSubmitReportByPostSlugIdPostRequest} apiV1ReportSubmitReportByPostSlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportSubmitReportByPostSlugIdPost: async (apiV1ReportSubmitReportByPostSlugIdPostRequest: ApiV1ReportSubmitReportByPostSlugIdPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ReportSubmitReportByPostSlugIdPostRequest' is not null or undefined
            assertParamExists('apiV1ReportSubmitReportByPostSlugIdPost', 'apiV1ReportSubmitReportByPostSlugIdPostRequest', apiV1ReportSubmitReportByPostSlugIdPostRequest)
            const localVarPath = `/api/v1/report/submit-report-by-post-slug-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ReportSubmitReportByPostSlugIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserFetchUserCommentsPostRequest} [apiV1UserFetchUserCommentsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserFetchUserCommentsPost: async (apiV1UserFetchUserCommentsPostRequest?: ApiV1UserFetchUserCommentsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/fetch-user-comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserFetchUserCommentsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserFetchUserPostsPostRequest} [apiV1UserFetchUserPostsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserFetchUserPostsPost: async (apiV1UserFetchUserPostsPostRequest?: ApiV1UserFetchUserPostsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/fetch-user-posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserFetchUserPostsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserFetchUserProfilePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/fetch-user-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMuteFetchPreferencesPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user-mute/fetch-preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserMuteMuteUserPostRequest} apiV1UserMuteMuteUserPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMuteMuteUserPost: async (apiV1UserMuteMuteUserPostRequest: ApiV1UserMuteMuteUserPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UserMuteMuteUserPostRequest' is not null or undefined
            assertParamExists('apiV1UserMuteMuteUserPost', 'apiV1UserMuteMuteUserPostRequest', apiV1UserMuteMuteUserPostRequest)
            const localVarPath = `/api/v1/user-mute/mute-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserMuteMuteUserPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1VotingCastVotePostRequest} apiV1VotingCastVotePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VotingCastVotePost: async (apiV1VotingCastVotePostRequest: ApiV1VotingCastVotePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1VotingCastVotePostRequest' is not null or undefined
            assertParamExists('apiV1VotingCastVotePost', 'apiV1VotingCastVotePostRequest', apiV1VotingCastVotePostRequest)
            const localVarPath = `/api/v1/voting/cast-vote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1VotingCastVotePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest} apiV1VotingFetchUserVotesForPostSlugIdsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VotingFetchUserVotesForPostSlugIdsPost: async (apiV1VotingFetchUserVotesForPostSlugIdsPostRequest: ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1VotingFetchUserVotesForPostSlugIdsPostRequest' is not null or undefined
            assertParamExists('apiV1VotingFetchUserVotesForPostSlugIdsPost', 'apiV1VotingFetchUserVotesForPostSlugIdsPostRequest', apiV1VotingFetchUserVotesForPostSlugIdsPostRequest)
            const localVarPath = `/api/v1/voting/fetch-user-votes-for-post-slug-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1VotingFetchUserVotesForPostSlugIdsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccountDeleteUserPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccountDeleteUserPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AccountDeleteUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccountGenerateUnusedRandomUsernamePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccountGenerateUnusedRandomUsernamePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AccountGenerateUnusedRandomUsernamePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AccountSubmitUsernameChangePostRequest} apiV1AccountSubmitUsernameChangePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccountIsUsernameInUsePost(apiV1AccountSubmitUsernameChangePostRequest: ApiV1AccountSubmitUsernameChangePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccountIsUsernameInUsePost(apiV1AccountSubmitUsernameChangePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AccountIsUsernameInUsePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AccountSubmitUsernameChangePostRequest} apiV1AccountSubmitUsernameChangePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccountSubmitUsernameChangePost(apiV1AccountSubmitUsernameChangePostRequest: ApiV1AccountSubmitUsernameChangePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccountSubmitUsernameChangePost(apiV1AccountSubmitUsernameChangePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AccountSubmitUsernameChangePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AuthAuthenticatePostRequest} apiV1AuthAuthenticatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest: ApiV1AuthAuthenticatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthAuthenticatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthAuthenticatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthCheckLoginStatusPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthCheckLoginStatusPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthCheckLoginStatusPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AuthVerifyPhoneOtpPostRequest} apiV1AuthVerifyPhoneOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthVerifyPhoneOtpPost(apiV1AuthVerifyPhoneOtpPostRequest: ApiV1AuthVerifyPhoneOtpPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthVerifyPhoneOtpPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthVerifyPhoneOtpPost(apiV1AuthVerifyPhoneOtpPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthVerifyPhoneOtpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthZkpGenerateVerificationLinkPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthZkpGenerateVerificationLinkPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthZkpGenerateVerificationLinkPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthZkpGenerateVerificationLinkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthZkpVerifyUserStatusAndAuthenticatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1CommentCreatePostRequest} apiV1CommentCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CommentCreatePost(apiV1CommentCreatePostRequest: ApiV1CommentCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1CommentCreatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CommentCreatePost(apiV1CommentCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1CommentCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CommentDeletePost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CommentDeletePost(apiV1ModerationCommentWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1CommentDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1CommentFetchCommentsByPostSlugIdPostRequest} apiV1CommentFetchCommentsByPostSlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CommentFetchCommentsByPostSlugIdPost(apiV1CommentFetchCommentsByPostSlugIdPostRequest: ApiV1CommentFetchCommentsByPostSlugIdPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CommentFetchCommentsByPostSlugIdPost(apiV1CommentFetchCommentsByPostSlugIdPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1CommentFetchCommentsByPostSlugIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1CommentFetchHiddenCommentsPostRequest} apiV1CommentFetchHiddenCommentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CommentFetchHiddenCommentsPost(apiV1CommentFetchHiddenCommentsPostRequest: ApiV1CommentFetchHiddenCommentsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CommentFetchHiddenCommentsPost(apiV1CommentFetchHiddenCommentsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1CommentFetchHiddenCommentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1FeedFetchRecentPostRequest} apiV1FeedFetchRecentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FeedFetchRecentPost(apiV1FeedFetchRecentPostRequest: ApiV1FeedFetchRecentPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1FeedFetchRecentPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1FeedFetchRecentPost(apiV1FeedFetchRecentPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1FeedFetchRecentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationCommentCreatePostRequest} apiV1ModerationCommentCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationCommentCreatePost(apiV1ModerationCommentCreatePostRequest: ApiV1ModerationCommentCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationCommentCreatePost(apiV1ModerationCommentCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationCommentCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationCommentFetchReportPost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ModerationCommentFetchReportPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationCommentFetchReportPost(apiV1ModerationCommentWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationCommentFetchReportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationCommentWithdrawPost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationCommentWithdrawPost(apiV1ModerationCommentWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationCommentWithdrawPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationPostCreatePostRequest} apiV1ModerationPostCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationPostCreatePost(apiV1ModerationPostCreatePostRequest: ApiV1ModerationPostCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationPostCreatePost(apiV1ModerationPostCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationPostCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationPostFetchReportPost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationPostFetchReportPost(apiV1ModerationPostWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationPostFetchReportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationPostWithdrawPost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationPostWithdrawPost(apiV1ModerationPostWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationPostWithdrawPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PollGetUserPollResponsePost(requestBody?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1PollGetUserPollResponsePost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PollGetUserPollResponsePost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1PollGetUserPollResponsePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PollSubmitResponsePostRequest} apiV1PollSubmitResponsePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PollSubmitResponsePost(apiV1PollSubmitResponsePostRequest: ApiV1PollSubmitResponsePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PollSubmitResponsePost(apiV1PollSubmitResponsePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1PollSubmitResponsePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PostCreatePostRequest} apiV1PostCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PostCreatePost(apiV1PostCreatePostRequest: ApiV1PostCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1PostCreatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PostCreatePost(apiV1PostCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1PostCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PostDeletePost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PostDeletePost(apiV1ModerationPostWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1PostDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PostFetchPostBySlugIdPostRequest} apiV1PostFetchPostBySlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PostFetchPostBySlugIdPost(apiV1PostFetchPostBySlugIdPostRequest: ApiV1PostFetchPostBySlugIdPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1PostFetchPostBySlugIdPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PostFetchPostBySlugIdPost(apiV1PostFetchPostBySlugIdPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1PostFetchPostBySlugIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ReportFetchReportsByCommentSlugIdPost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ReportFetchReportsByCommentSlugIdPost(apiV1ModerationCommentWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ReportFetchReportsByCommentSlugIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ReportFetchReportsByPostSlugIdPost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ReportFetchReportsByPostSlugIdPost(apiV1ModerationPostWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ReportFetchReportsByPostSlugIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ReportSubmitReportByCommentSlugIdPostRequest} apiV1ReportSubmitReportByCommentSlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ReportSubmitReportByCommentSlugIdPost(apiV1ReportSubmitReportByCommentSlugIdPostRequest: ApiV1ReportSubmitReportByCommentSlugIdPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ReportSubmitReportByCommentSlugIdPost(apiV1ReportSubmitReportByCommentSlugIdPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ReportSubmitReportByCommentSlugIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ReportSubmitReportByPostSlugIdPostRequest} apiV1ReportSubmitReportByPostSlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ReportSubmitReportByPostSlugIdPost(apiV1ReportSubmitReportByPostSlugIdPostRequest: ApiV1ReportSubmitReportByPostSlugIdPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ReportSubmitReportByPostSlugIdPost(apiV1ReportSubmitReportByPostSlugIdPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ReportSubmitReportByPostSlugIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserFetchUserCommentsPostRequest} [apiV1UserFetchUserCommentsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserFetchUserCommentsPost(apiV1UserFetchUserCommentsPostRequest?: ApiV1UserFetchUserCommentsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UserFetchUserCommentsPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserFetchUserCommentsPost(apiV1UserFetchUserCommentsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserFetchUserCommentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserFetchUserPostsPostRequest} [apiV1UserFetchUserPostsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserFetchUserPostsPost(apiV1UserFetchUserPostsPostRequest?: ApiV1UserFetchUserPostsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1FeedFetchRecentPost200ResponsePostDataListInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserFetchUserPostsPost(apiV1UserFetchUserPostsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserFetchUserPostsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserFetchUserProfilePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UserFetchUserProfilePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserFetchUserProfilePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserFetchUserProfilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMuteFetchPreferencesPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserMuteFetchPreferencesPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserMuteFetchPreferencesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserMuteMuteUserPostRequest} apiV1UserMuteMuteUserPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserMuteMuteUserPost(apiV1UserMuteMuteUserPostRequest: ApiV1UserMuteMuteUserPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserMuteMuteUserPost(apiV1UserMuteMuteUserPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserMuteMuteUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1VotingCastVotePostRequest} apiV1VotingCastVotePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VotingCastVotePost(apiV1VotingCastVotePostRequest: ApiV1VotingCastVotePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VotingCastVotePost(apiV1VotingCastVotePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1VotingCastVotePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest} apiV1VotingFetchUserVotesForPostSlugIdsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VotingFetchUserVotesForPostSlugIdsPost(apiV1VotingFetchUserVotesForPostSlugIdsPostRequest: ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VotingFetchUserVotesForPostSlugIdsPost(apiV1VotingFetchUserVotesForPostSlugIdsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1VotingFetchUserVotesForPostSlugIdsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountDeleteUserPost(options?: any): AxiosPromise<void> {
            return localVarFp.apiV1AccountDeleteUserPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountGenerateUnusedRandomUsernamePost(options?: any): AxiosPromise<string> {
            return localVarFp.apiV1AccountGenerateUnusedRandomUsernamePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AccountSubmitUsernameChangePostRequest} apiV1AccountSubmitUsernameChangePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountIsUsernameInUsePost(apiV1AccountSubmitUsernameChangePostRequest: ApiV1AccountSubmitUsernameChangePostRequest, options?: any): AxiosPromise<boolean> {
            return localVarFp.apiV1AccountIsUsernameInUsePost(apiV1AccountSubmitUsernameChangePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AccountSubmitUsernameChangePostRequest} apiV1AccountSubmitUsernameChangePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountSubmitUsernameChangePost(apiV1AccountSubmitUsernameChangePostRequest: ApiV1AccountSubmitUsernameChangePostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1AccountSubmitUsernameChangePost(apiV1AccountSubmitUsernameChangePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AuthAuthenticatePostRequest} apiV1AuthAuthenticatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest: ApiV1AuthAuthenticatePostRequest, options?: any): AxiosPromise<ApiV1AuthAuthenticatePost200Response> {
            return localVarFp.apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthCheckLoginStatusPost(options?: any): AxiosPromise<object> {
            return localVarFp.apiV1AuthCheckLoginStatusPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLogoutPost(options?: any): AxiosPromise<void> {
            return localVarFp.apiV1AuthLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AuthVerifyPhoneOtpPostRequest} apiV1AuthVerifyPhoneOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthVerifyPhoneOtpPost(apiV1AuthVerifyPhoneOtpPostRequest: ApiV1AuthVerifyPhoneOtpPostRequest, options?: any): AxiosPromise<ApiV1AuthVerifyPhoneOtpPost200Response> {
            return localVarFp.apiV1AuthVerifyPhoneOtpPost(apiV1AuthVerifyPhoneOtpPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthZkpGenerateVerificationLinkPost(options?: any): AxiosPromise<ApiV1AuthZkpGenerateVerificationLinkPost200Response> {
            return localVarFp.apiV1AuthZkpGenerateVerificationLinkPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options?: any): AxiosPromise<ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response> {
            return localVarFp.apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1CommentCreatePostRequest} apiV1CommentCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CommentCreatePost(apiV1CommentCreatePostRequest: ApiV1CommentCreatePostRequest, options?: any): AxiosPromise<ApiV1CommentCreatePost200Response> {
            return localVarFp.apiV1CommentCreatePost(apiV1CommentCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CommentDeletePost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1CommentDeletePost(apiV1ModerationCommentWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1CommentFetchCommentsByPostSlugIdPostRequest} apiV1CommentFetchCommentsByPostSlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CommentFetchCommentsByPostSlugIdPost(apiV1CommentFetchCommentsByPostSlugIdPostRequest: ApiV1CommentFetchCommentsByPostSlugIdPostRequest, options?: any): AxiosPromise<Array<ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem>> {
            return localVarFp.apiV1CommentFetchCommentsByPostSlugIdPost(apiV1CommentFetchCommentsByPostSlugIdPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1CommentFetchHiddenCommentsPostRequest} apiV1CommentFetchHiddenCommentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CommentFetchHiddenCommentsPost(apiV1CommentFetchHiddenCommentsPostRequest: ApiV1CommentFetchHiddenCommentsPostRequest, options?: any): AxiosPromise<Array<ApiV1UserFetchUserCommentsPost200ResponseInnerCommentItem>> {
            return localVarFp.apiV1CommentFetchHiddenCommentsPost(apiV1CommentFetchHiddenCommentsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1FeedFetchRecentPostRequest} apiV1FeedFetchRecentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedFetchRecentPost(apiV1FeedFetchRecentPostRequest: ApiV1FeedFetchRecentPostRequest, options?: any): AxiosPromise<ApiV1FeedFetchRecentPost200Response> {
            return localVarFp.apiV1FeedFetchRecentPost(apiV1FeedFetchRecentPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationCommentCreatePostRequest} apiV1ModerationCommentCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationCommentCreatePost(apiV1ModerationCommentCreatePostRequest: ApiV1ModerationCommentCreatePostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1ModerationCommentCreatePost(apiV1ModerationCommentCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationCommentFetchReportPost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: any): AxiosPromise<ApiV1ModerationCommentFetchReportPost200Response> {
            return localVarFp.apiV1ModerationCommentFetchReportPost(apiV1ModerationCommentWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationCommentWithdrawPost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1ModerationCommentWithdrawPost(apiV1ModerationCommentWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationPostCreatePostRequest} apiV1ModerationPostCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationPostCreatePost(apiV1ModerationPostCreatePostRequest: ApiV1ModerationPostCreatePostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1ModerationPostCreatePost(apiV1ModerationPostCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationPostFetchReportPost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: any): AxiosPromise<ApiV1FeedFetchRecentPost200ResponsePostDataListInnerMetadataModeration> {
            return localVarFp.apiV1ModerationPostFetchReportPost(apiV1ModerationPostWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationPostWithdrawPost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1ModerationPostWithdrawPost(apiV1ModerationPostWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PollGetUserPollResponsePost(requestBody?: Array<string>, options?: any): AxiosPromise<Array<ApiV1PollGetUserPollResponsePost200ResponseInner>> {
            return localVarFp.apiV1PollGetUserPollResponsePost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PollSubmitResponsePostRequest} apiV1PollSubmitResponsePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PollSubmitResponsePost(apiV1PollSubmitResponsePostRequest: ApiV1PollSubmitResponsePostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1PollSubmitResponsePost(apiV1PollSubmitResponsePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PostCreatePostRequest} apiV1PostCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PostCreatePost(apiV1PostCreatePostRequest: ApiV1PostCreatePostRequest, options?: any): AxiosPromise<ApiV1PostCreatePost200Response> {
            return localVarFp.apiV1PostCreatePost(apiV1PostCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PostDeletePost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1PostDeletePost(apiV1ModerationPostWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PostFetchPostBySlugIdPostRequest} apiV1PostFetchPostBySlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PostFetchPostBySlugIdPost(apiV1PostFetchPostBySlugIdPostRequest: ApiV1PostFetchPostBySlugIdPostRequest, options?: any): AxiosPromise<ApiV1PostFetchPostBySlugIdPost200Response> {
            return localVarFp.apiV1PostFetchPostBySlugIdPost(apiV1PostFetchPostBySlugIdPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportFetchReportsByCommentSlugIdPost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: any): AxiosPromise<Array<ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner>> {
            return localVarFp.apiV1ReportFetchReportsByCommentSlugIdPost(apiV1ModerationCommentWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportFetchReportsByPostSlugIdPost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: any): AxiosPromise<Array<ApiV1ReportFetchReportsByPostSlugIdPost200ResponseInner>> {
            return localVarFp.apiV1ReportFetchReportsByPostSlugIdPost(apiV1ModerationPostWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ReportSubmitReportByCommentSlugIdPostRequest} apiV1ReportSubmitReportByCommentSlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportSubmitReportByCommentSlugIdPost(apiV1ReportSubmitReportByCommentSlugIdPostRequest: ApiV1ReportSubmitReportByCommentSlugIdPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1ReportSubmitReportByCommentSlugIdPost(apiV1ReportSubmitReportByCommentSlugIdPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ReportSubmitReportByPostSlugIdPostRequest} apiV1ReportSubmitReportByPostSlugIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportSubmitReportByPostSlugIdPost(apiV1ReportSubmitReportByPostSlugIdPostRequest: ApiV1ReportSubmitReportByPostSlugIdPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1ReportSubmitReportByPostSlugIdPost(apiV1ReportSubmitReportByPostSlugIdPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserFetchUserCommentsPostRequest} [apiV1UserFetchUserCommentsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserFetchUserCommentsPost(apiV1UserFetchUserCommentsPostRequest?: ApiV1UserFetchUserCommentsPostRequest, options?: any): AxiosPromise<Array<ApiV1UserFetchUserCommentsPost200ResponseInner>> {
            return localVarFp.apiV1UserFetchUserCommentsPost(apiV1UserFetchUserCommentsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserFetchUserPostsPostRequest} [apiV1UserFetchUserPostsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserFetchUserPostsPost(apiV1UserFetchUserPostsPostRequest?: ApiV1UserFetchUserPostsPostRequest, options?: any): AxiosPromise<Array<ApiV1FeedFetchRecentPost200ResponsePostDataListInner>> {
            return localVarFp.apiV1UserFetchUserPostsPost(apiV1UserFetchUserPostsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserFetchUserProfilePost(options?: any): AxiosPromise<ApiV1UserFetchUserProfilePost200Response> {
            return localVarFp.apiV1UserFetchUserProfilePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMuteFetchPreferencesPost(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.apiV1UserMuteFetchPreferencesPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserMuteMuteUserPostRequest} apiV1UserMuteMuteUserPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserMuteMuteUserPost(apiV1UserMuteMuteUserPostRequest: ApiV1UserMuteMuteUserPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1UserMuteMuteUserPost(apiV1UserMuteMuteUserPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1VotingCastVotePostRequest} apiV1VotingCastVotePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VotingCastVotePost(apiV1VotingCastVotePostRequest: ApiV1VotingCastVotePostRequest, options?: any): AxiosPromise<boolean> {
            return localVarFp.apiV1VotingCastVotePost(apiV1VotingCastVotePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest} apiV1VotingFetchUserVotesForPostSlugIdsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VotingFetchUserVotesForPostSlugIdsPost(apiV1VotingFetchUserVotesForPostSlugIdsPostRequest: ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest, options?: any): AxiosPromise<Array<ApiV1VotingFetchUserVotesForPostSlugIdsPost200ResponseInner>> {
            return localVarFp.apiV1VotingFetchUserVotesForPostSlugIdsPost(apiV1VotingFetchUserVotesForPostSlugIdsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AccountDeleteUserPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AccountDeleteUserPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AccountGenerateUnusedRandomUsernamePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AccountGenerateUnusedRandomUsernamePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AccountSubmitUsernameChangePostRequest} apiV1AccountSubmitUsernameChangePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AccountIsUsernameInUsePost(apiV1AccountSubmitUsernameChangePostRequest: ApiV1AccountSubmitUsernameChangePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AccountIsUsernameInUsePost(apiV1AccountSubmitUsernameChangePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AccountSubmitUsernameChangePostRequest} apiV1AccountSubmitUsernameChangePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AccountSubmitUsernameChangePost(apiV1AccountSubmitUsernameChangePostRequest: ApiV1AccountSubmitUsernameChangePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AccountSubmitUsernameChangePost(apiV1AccountSubmitUsernameChangePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AuthAuthenticatePostRequest} apiV1AuthAuthenticatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest: ApiV1AuthAuthenticatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AuthCheckLoginStatusPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthCheckLoginStatusPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AuthLogoutPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AuthVerifyPhoneOtpPostRequest} apiV1AuthVerifyPhoneOtpPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AuthVerifyPhoneOtpPost(apiV1AuthVerifyPhoneOtpPostRequest: ApiV1AuthVerifyPhoneOtpPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthVerifyPhoneOtpPost(apiV1AuthVerifyPhoneOtpPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AuthZkpGenerateVerificationLinkPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthZkpGenerateVerificationLinkPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1CommentCreatePostRequest} apiV1CommentCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1CommentCreatePost(apiV1CommentCreatePostRequest: ApiV1CommentCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1CommentCreatePost(apiV1CommentCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1CommentDeletePost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1CommentDeletePost(apiV1ModerationCommentWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1CommentFetchCommentsByPostSlugIdPostRequest} apiV1CommentFetchCommentsByPostSlugIdPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1CommentFetchCommentsByPostSlugIdPost(apiV1CommentFetchCommentsByPostSlugIdPostRequest: ApiV1CommentFetchCommentsByPostSlugIdPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1CommentFetchCommentsByPostSlugIdPost(apiV1CommentFetchCommentsByPostSlugIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1CommentFetchHiddenCommentsPostRequest} apiV1CommentFetchHiddenCommentsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1CommentFetchHiddenCommentsPost(apiV1CommentFetchHiddenCommentsPostRequest: ApiV1CommentFetchHiddenCommentsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1CommentFetchHiddenCommentsPost(apiV1CommentFetchHiddenCommentsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1FeedFetchRecentPostRequest} apiV1FeedFetchRecentPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1FeedFetchRecentPost(apiV1FeedFetchRecentPostRequest: ApiV1FeedFetchRecentPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1FeedFetchRecentPost(apiV1FeedFetchRecentPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationCommentCreatePostRequest} apiV1ModerationCommentCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ModerationCommentCreatePost(apiV1ModerationCommentCreatePostRequest: ApiV1ModerationCommentCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationCommentCreatePost(apiV1ModerationCommentCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ModerationCommentFetchReportPost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationCommentFetchReportPost(apiV1ModerationCommentWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ModerationCommentWithdrawPost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationCommentWithdrawPost(apiV1ModerationCommentWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationPostCreatePostRequest} apiV1ModerationPostCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ModerationPostCreatePost(apiV1ModerationPostCreatePostRequest: ApiV1ModerationPostCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationPostCreatePost(apiV1ModerationPostCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ModerationPostFetchReportPost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationPostFetchReportPost(apiV1ModerationPostWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ModerationPostWithdrawPost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationPostWithdrawPost(apiV1ModerationPostWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1PollGetUserPollResponsePost(requestBody?: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1PollGetUserPollResponsePost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1PollSubmitResponsePostRequest} apiV1PollSubmitResponsePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1PollSubmitResponsePost(apiV1PollSubmitResponsePostRequest: ApiV1PollSubmitResponsePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1PollSubmitResponsePost(apiV1PollSubmitResponsePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1PostCreatePostRequest} apiV1PostCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1PostCreatePost(apiV1PostCreatePostRequest: ApiV1PostCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1PostCreatePost(apiV1PostCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1PostDeletePost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1PostDeletePost(apiV1ModerationPostWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1PostFetchPostBySlugIdPostRequest} apiV1PostFetchPostBySlugIdPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1PostFetchPostBySlugIdPost(apiV1PostFetchPostBySlugIdPostRequest: ApiV1PostFetchPostBySlugIdPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1PostFetchPostBySlugIdPost(apiV1PostFetchPostBySlugIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationCommentWithdrawPostRequest} apiV1ModerationCommentWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ReportFetchReportsByCommentSlugIdPost(apiV1ModerationCommentWithdrawPostRequest: ApiV1ModerationCommentWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ReportFetchReportsByCommentSlugIdPost(apiV1ModerationCommentWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationPostWithdrawPostRequest} apiV1ModerationPostWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ReportFetchReportsByPostSlugIdPost(apiV1ModerationPostWithdrawPostRequest: ApiV1ModerationPostWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ReportFetchReportsByPostSlugIdPost(apiV1ModerationPostWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ReportSubmitReportByCommentSlugIdPostRequest} apiV1ReportSubmitReportByCommentSlugIdPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ReportSubmitReportByCommentSlugIdPost(apiV1ReportSubmitReportByCommentSlugIdPostRequest: ApiV1ReportSubmitReportByCommentSlugIdPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ReportSubmitReportByCommentSlugIdPost(apiV1ReportSubmitReportByCommentSlugIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ReportSubmitReportByPostSlugIdPostRequest} apiV1ReportSubmitReportByPostSlugIdPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ReportSubmitReportByPostSlugIdPost(apiV1ReportSubmitReportByPostSlugIdPostRequest: ApiV1ReportSubmitReportByPostSlugIdPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ReportSubmitReportByPostSlugIdPost(apiV1ReportSubmitReportByPostSlugIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserFetchUserCommentsPostRequest} [apiV1UserFetchUserCommentsPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1UserFetchUserCommentsPost(apiV1UserFetchUserCommentsPostRequest?: ApiV1UserFetchUserCommentsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserFetchUserCommentsPost(apiV1UserFetchUserCommentsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserFetchUserPostsPostRequest} [apiV1UserFetchUserPostsPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1UserFetchUserPostsPost(apiV1UserFetchUserPostsPostRequest?: ApiV1UserFetchUserPostsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserFetchUserPostsPost(apiV1UserFetchUserPostsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1UserFetchUserProfilePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserFetchUserProfilePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1UserMuteFetchPreferencesPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserMuteFetchPreferencesPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserMuteMuteUserPostRequest} apiV1UserMuteMuteUserPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1UserMuteMuteUserPost(apiV1UserMuteMuteUserPostRequest: ApiV1UserMuteMuteUserPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserMuteMuteUserPost(apiV1UserMuteMuteUserPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1VotingCastVotePostRequest} apiV1VotingCastVotePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1VotingCastVotePost(apiV1VotingCastVotePostRequest: ApiV1VotingCastVotePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1VotingCastVotePost(apiV1VotingCastVotePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest} apiV1VotingFetchUserVotesForPostSlugIdsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1VotingFetchUserVotesForPostSlugIdsPost(apiV1VotingFetchUserVotesForPostSlugIdsPostRequest: ApiV1VotingFetchUserVotesForPostSlugIdsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1VotingFetchUserVotesForPostSlugIdsPost(apiV1VotingFetchUserVotesForPostSlugIdsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



