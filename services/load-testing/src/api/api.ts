/* tslint:disable */
/* eslint-disable */
/**
 * Agora Citizen Network
 * Agora API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest {
    'username': string;
    'organizationName': string;
}
export interface ApiV1AdministratorOrganizationCreateOrganizationPostRequest {
    'organizationName': string;
    'imagePath': string;
    'isFullImagePath': boolean;
    'websiteUrl': string;
    'description': string;
}
export interface ApiV1AdministratorOrganizationDeleteOrganizationPostRequest {
    'organizationName': string;
}
export interface ApiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost200Response {
    'organizationList': Array<ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataOrganization>;
}
/**
 * @type ApiV1AuthAuthenticatePost200Response
 */
export type ApiV1AuthAuthenticatePost200Response = ApiV1AuthAuthenticatePost200ResponseOneOf | ApiV1AuthAuthenticatePost200ResponseOneOf1;

export interface ApiV1AuthAuthenticatePost200ResponseOneOf {
    'success': boolean;
    'codeExpiry': string;
    'nextCodeSoonestTime': string;
}
export interface ApiV1AuthAuthenticatePost200ResponseOneOf1 {
    'success': boolean;
    'reason': ApiV1AuthAuthenticatePost200ResponseOneOf1ReasonEnum;
}

export const ApiV1AuthAuthenticatePost200ResponseOneOf1ReasonEnum = {
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user',
    Throttled: 'throttled',
    InvalidPhoneNumber: 'invalid_phone_number',
    RestrictedPhoneType: 'restricted_phone_type'
} as const;

export type ApiV1AuthAuthenticatePost200ResponseOneOf1ReasonEnum = typeof ApiV1AuthAuthenticatePost200ResponseOneOf1ReasonEnum[keyof typeof ApiV1AuthAuthenticatePost200ResponseOneOf1ReasonEnum];

export interface ApiV1AuthAuthenticatePostRequest {
    /**
     * Phone number
     */
    'phoneNumber': string;
    'defaultCallingCode': ApiV1AuthAuthenticatePostRequestDefaultCallingCodeEnum;
    'isRequestingNewCode': boolean;
}

export const ApiV1AuthAuthenticatePostRequestDefaultCallingCodeEnum = {
    _1: '1',
    _7: '7',
    _20: '20',
    _27: '27',
    _30: '30',
    _31: '31',
    _32: '32',
    _33: '33',
    _34: '34',
    _36: '36',
    _38: '38',
    _39: '39',
    _40: '40',
    _41: '41',
    _43: '43',
    _44: '44',
    _45: '45',
    _46: '46',
    _47: '47',
    _48: '48',
    _49: '49',
    _51: '51',
    _52: '52',
    _54: '54',
    _55: '55',
    _56: '56',
    _57: '57',
    _58: '58',
    _60: '60',
    _61: '61',
    _62: '62',
    _63: '63',
    _64: '64',
    _65: '65',
    _66: '66',
    _81: '81',
    _82: '82',
    _84: '84',
    _86: '86',
    _90: '90',
    _91: '91',
    _92: '92',
    _93: '93',
    _94: '94',
    _95: '95',
    _98: '98',
    _211: '211',
    _212: '212',
    _213: '213',
    _216: '216',
    _218: '218',
    _221: '221',
    _223: '223',
    _224: '224',
    _225: '225',
    _226: '226',
    _227: '227',
    _229: '229',
    _234: '234',
    _235: '235',
    _236: '236',
    _237: '237',
    _240: '240',
    _242: '242',
    _243: '243',
    _245: '245',
    _246: '246',
    _249: '249',
    _250: '250',
    _251: '251',
    _252: '252',
    _254: '254',
    _255: '255',
    _256: '256',
    _257: '257',
    _258: '258',
    _260: '260',
    _262: '262',
    _297: '297',
    _298: '298',
    _299: '299',
    _350: '350',
    _351: '351',
    _352: '352',
    _353: '353',
    _354: '354',
    _355: '355',
    _356: '356',
    _358: '358',
    _359: '359',
    _370: '370',
    _371: '371',
    _372: '372',
    _373: '373',
    _374: '374',
    _375: '375',
    _376: '376',
    _377: '377',
    _378: '378',
    _380: '380',
    _381: '381',
    _382: '382',
    _383: '383',
    _385: '385',
    _386: '386',
    _387: '387',
    _389: '389',
    _420: '420',
    _421: '421',
    _423: '423',
    _502: '502',
    _508: '508',
    _509: '509',
    _590: '590',
    _593: '593',
    _596: '596',
    _599: '599',
    _675: '675',
    _687: '687',
    _689: '689',
    _852: '852',
    _855: '855',
    _880: '880',
    _886: '886',
    _961: '961',
    _962: '962',
    _963: '963',
    _964: '964',
    _966: '966',
    _967: '967',
    _968: '968',
    _970: '970',
    _971: '971',
    _972: '972',
    _974: '974',
    _977: '977',
    _992: '992',
    _995: '995',
    _996: '996',
    _998: '998',
    _1284: '1284',
    _1340: '1340',
    _1684: '1684',
    _1721: '1721',
    _4779: '4779',
    _5993: '5993',
    _5999: '5999',
    _35818: '35818',
    _441481: '441481',
    _441534: '441534',
    _441624: '441624',
    _3906698: '3906698'
} as const;

export type ApiV1AuthAuthenticatePostRequestDefaultCallingCodeEnum = typeof ApiV1AuthAuthenticatePostRequestDefaultCallingCodeEnum[keyof typeof ApiV1AuthAuthenticatePostRequestDefaultCallingCodeEnum];

export interface ApiV1AuthCheckLoginStatusPost200Response {
    'loggedInStatus': ApiV1AuthCheckLoginStatusPost200ResponseLoggedInStatus;
}
/**
 * @type ApiV1AuthCheckLoginStatusPost200ResponseLoggedInStatus
 */
export type ApiV1AuthCheckLoginStatusPost200ResponseLoggedInStatus = ApiV1AuthCheckLoginStatusPost200ResponseLoggedInStatusOneOf | ApiV1AuthCheckLoginStatusPost200ResponseLoggedInStatusOneOf1;

export interface ApiV1AuthCheckLoginStatusPost200ResponseLoggedInStatusOneOf {
    'isKnown': boolean;
    'isRegistered': boolean;
    'isLoggedIn': boolean;
}
export interface ApiV1AuthCheckLoginStatusPost200ResponseLoggedInStatusOneOf1 {
    'isKnown': boolean;
    'isRegistered': boolean;
    'isLoggedIn': boolean;
    'userId': string;
}
/**
 * @type ApiV1AuthPhoneVerifyOtpPost200Response
 */
export type ApiV1AuthPhoneVerifyOtpPost200Response = ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf | ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf1;

export interface ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf {
    'success': boolean;
    'accountMerged': boolean;
    'userId': string;
}
export interface ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf1 {
    'success': boolean;
    'reason': ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf1ReasonEnum;
}

export const ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf1ReasonEnum = {
    ExpiredCode: 'expired_code',
    WrongGuess: 'wrong_guess',
    TooManyWrongGuess: 'too_many_wrong_guess',
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user',
    AuthStateChanged: 'auth_state_changed'
} as const;

export type ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf1ReasonEnum = typeof ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf1ReasonEnum[keyof typeof ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf1ReasonEnum];

export interface ApiV1AuthPhoneVerifyOtpPostRequest {
    'code': number;
    /**
     * Phone number
     */
    'phoneNumber': string;
    'defaultCallingCode': ApiV1AuthPhoneVerifyOtpPostRequestDefaultCallingCodeEnum;
}

export const ApiV1AuthPhoneVerifyOtpPostRequestDefaultCallingCodeEnum = {
    _1: '1',
    _7: '7',
    _20: '20',
    _27: '27',
    _30: '30',
    _31: '31',
    _32: '32',
    _33: '33',
    _34: '34',
    _36: '36',
    _38: '38',
    _39: '39',
    _40: '40',
    _41: '41',
    _43: '43',
    _44: '44',
    _45: '45',
    _46: '46',
    _47: '47',
    _48: '48',
    _49: '49',
    _51: '51',
    _52: '52',
    _54: '54',
    _55: '55',
    _56: '56',
    _57: '57',
    _58: '58',
    _60: '60',
    _61: '61',
    _62: '62',
    _63: '63',
    _64: '64',
    _65: '65',
    _66: '66',
    _81: '81',
    _82: '82',
    _84: '84',
    _86: '86',
    _90: '90',
    _91: '91',
    _92: '92',
    _93: '93',
    _94: '94',
    _95: '95',
    _98: '98',
    _211: '211',
    _212: '212',
    _213: '213',
    _216: '216',
    _218: '218',
    _221: '221',
    _223: '223',
    _224: '224',
    _225: '225',
    _226: '226',
    _227: '227',
    _229: '229',
    _234: '234',
    _235: '235',
    _236: '236',
    _237: '237',
    _240: '240',
    _242: '242',
    _243: '243',
    _245: '245',
    _246: '246',
    _249: '249',
    _250: '250',
    _251: '251',
    _252: '252',
    _254: '254',
    _255: '255',
    _256: '256',
    _257: '257',
    _258: '258',
    _260: '260',
    _262: '262',
    _297: '297',
    _298: '298',
    _299: '299',
    _350: '350',
    _351: '351',
    _352: '352',
    _353: '353',
    _354: '354',
    _355: '355',
    _356: '356',
    _358: '358',
    _359: '359',
    _370: '370',
    _371: '371',
    _372: '372',
    _373: '373',
    _374: '374',
    _375: '375',
    _376: '376',
    _377: '377',
    _378: '378',
    _380: '380',
    _381: '381',
    _382: '382',
    _383: '383',
    _385: '385',
    _386: '386',
    _387: '387',
    _389: '389',
    _420: '420',
    _421: '421',
    _423: '423',
    _502: '502',
    _508: '508',
    _509: '509',
    _590: '590',
    _593: '593',
    _596: '596',
    _599: '599',
    _675: '675',
    _687: '687',
    _689: '689',
    _852: '852',
    _855: '855',
    _880: '880',
    _886: '886',
    _961: '961',
    _962: '962',
    _963: '963',
    _964: '964',
    _966: '966',
    _967: '967',
    _968: '968',
    _970: '970',
    _971: '971',
    _972: '972',
    _974: '974',
    _977: '977',
    _992: '992',
    _995: '995',
    _996: '996',
    _998: '998',
    _1284: '1284',
    _1340: '1340',
    _1684: '1684',
    _1721: '1721',
    _4779: '4779',
    _5993: '5993',
    _5999: '5999',
    _35818: '35818',
    _441481: '441481',
    _441534: '441534',
    _441624: '441624',
    _3906698: '3906698'
} as const;

export type ApiV1AuthPhoneVerifyOtpPostRequestDefaultCallingCodeEnum = typeof ApiV1AuthPhoneVerifyOtpPostRequestDefaultCallingCodeEnum[keyof typeof ApiV1AuthPhoneVerifyOtpPostRequestDefaultCallingCodeEnum];

/**
 * @type ApiV1AuthTicketVerifyPost200Response
 */
export type ApiV1AuthTicketVerifyPost200Response = ApiV1AuthPhoneVerifyOtpPost200ResponseOneOf | ApiV1AuthTicketVerifyPost200ResponseOneOf;

export interface ApiV1AuthTicketVerifyPost200ResponseOneOf {
    'success': boolean;
    'reason': ApiV1AuthTicketVerifyPost200ResponseOneOfReasonEnum;
}

export const ApiV1AuthTicketVerifyPost200ResponseOneOfReasonEnum = {
    DeserializationError: 'deserialization_error',
    InvalidProof: 'invalid_proof',
    InvalidSigner: 'invalid_signer',
    WrongEvent: 'wrong_event',
    TicketAlreadyUsed: 'ticket_already_used'
} as const;

export type ApiV1AuthTicketVerifyPost200ResponseOneOfReasonEnum = typeof ApiV1AuthTicketVerifyPost200ResponseOneOfReasonEnum[keyof typeof ApiV1AuthTicketVerifyPost200ResponseOneOfReasonEnum];

export interface ApiV1AuthTicketVerifyPostRequest {
    'proof': any;
    'eventSlug': ApiV1AuthTicketVerifyPostRequestEventSlugEnum;
}

export const ApiV1AuthTicketVerifyPostRequestEventSlugEnum = {
    Devconnect2025: 'devconnect-2025'
} as const;

export type ApiV1AuthTicketVerifyPostRequestEventSlugEnum = typeof ApiV1AuthTicketVerifyPostRequestEventSlugEnum[keyof typeof ApiV1AuthTicketVerifyPostRequestEventSlugEnum];

/**
 * @type ApiV1AuthZkpGenerateVerificationLinkPost200Response
 */
export type ApiV1AuthZkpGenerateVerificationLinkPost200Response = ApiV1AuthZkpGenerateVerificationLinkPost200ResponseOneOf | ApiV1AuthZkpGenerateVerificationLinkPost200ResponseOneOf1;

export interface ApiV1AuthZkpGenerateVerificationLinkPost200ResponseOneOf {
    'success': boolean;
    'verificationLink': string;
}
export interface ApiV1AuthZkpGenerateVerificationLinkPost200ResponseOneOf1 {
    'success': boolean;
    'reason': ApiV1AuthZkpGenerateVerificationLinkPost200ResponseOneOf1ReasonEnum;
}

export const ApiV1AuthZkpGenerateVerificationLinkPost200ResponseOneOf1ReasonEnum = {
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user'
} as const;

export type ApiV1AuthZkpGenerateVerificationLinkPost200ResponseOneOf1ReasonEnum = typeof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseOneOf1ReasonEnum[keyof typeof ApiV1AuthZkpGenerateVerificationLinkPost200ResponseOneOf1ReasonEnum];

export interface ApiV1AuthZkpGenerateVerificationLinkPostRequest {
    'linkType': ApiV1AuthZkpGenerateVerificationLinkPostRequestLinkTypeEnum;
}

export const ApiV1AuthZkpGenerateVerificationLinkPostRequestLinkTypeEnum = {
    Http: 'http',
    Deep: 'deep'
} as const;

export type ApiV1AuthZkpGenerateVerificationLinkPostRequestLinkTypeEnum = typeof ApiV1AuthZkpGenerateVerificationLinkPostRequestLinkTypeEnum[keyof typeof ApiV1AuthZkpGenerateVerificationLinkPostRequestLinkTypeEnum];

export interface ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response {
    'success': boolean;
    'rarimoStatus': ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum;
    'accountMerged': boolean;
    'userId': string;
    'reason': ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum;
}

export const ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum = {
    NotVerified: 'not_verified',
    FailedVerification: 'failed_verification',
    UniquenessCheckFailed: 'uniqueness_check_failed'
} as const;

export type ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum = typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum[keyof typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseRarimoStatusEnum];
export const ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum = {
    AlreadyLoggedIn: 'already_logged_in',
    AssociatedWithAnotherUser: 'associated_with_another_user'
} as const;

export type ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum = typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum[keyof typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseReasonEnum];

export interface ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf {
    'success': boolean;
    'rarimoStatus': ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum;
    'accountMerged': boolean;
    'userId': string;
}

export const ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum = {
    Verified: 'verified'
} as const;

export type ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum = typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum[keyof typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOfRarimoStatusEnum];

export interface ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf1 {
    'success': boolean;
    'rarimoStatus': ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf1RarimoStatusEnum;
}

export const ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf1RarimoStatusEnum = {
    NotVerified: 'not_verified',
    FailedVerification: 'failed_verification',
    UniquenessCheckFailed: 'uniqueness_check_failed'
} as const;

export type ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf1RarimoStatusEnum = typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf1RarimoStatusEnum[keyof typeof ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200ResponseAnyOf1RarimoStatusEnum];

/**
 * @type ApiV1ConversationClosePost200Response
 */
export type ApiV1ConversationClosePost200Response = ApiV1ConversationClosePost200ResponseOneOf | ApiV1ConversationClosePost200ResponseOneOf1;

export interface ApiV1ConversationClosePost200ResponseOneOf {
    'success': boolean;
}
export interface ApiV1ConversationClosePost200ResponseOneOf1 {
    'success': boolean;
    'reason': ApiV1ConversationClosePost200ResponseOneOf1ReasonEnum;
}

export const ApiV1ConversationClosePost200ResponseOneOf1ReasonEnum = {
    NotAllowed: 'not_allowed',
    AlreadyClosed: 'already_closed'
} as const;

export type ApiV1ConversationClosePost200ResponseOneOf1ReasonEnum = typeof ApiV1ConversationClosePost200ResponseOneOf1ReasonEnum[keyof typeof ApiV1ConversationClosePost200ResponseOneOf1ReasonEnum];

export interface ApiV1ConversationCreatePost200Response {
    'conversationSlugId': string;
}
export interface ApiV1ConversationCreatePostRequest {
    'conversationTitle': string;
    'conversationBody'?: string;
    'postAsOrganization'?: string;
    'indexConversationAt'?: string;
    'isIndexed': boolean;
    'isLoginRequired': boolean;
    'pollingOptionList'?: Array<string>;
    'seedOpinionList': Array<string>;
    'requiresEventTicket'?: ApiV1ConversationCreatePostRequestRequiresEventTicketEnum;
}

export const ApiV1ConversationCreatePostRequestRequiresEventTicketEnum = {
    Devconnect2025: 'devconnect-2025'
} as const;

export type ApiV1ConversationCreatePostRequestRequiresEventTicketEnum = typeof ApiV1ConversationCreatePostRequestRequiresEventTicketEnum[keyof typeof ApiV1ConversationCreatePostRequestRequiresEventTicketEnum];

export interface ApiV1ConversationExportHistoryPost200ResponseInner {
    'exportSlugId': string;
    'status': ApiV1ConversationExportHistoryPost200ResponseInnerStatusEnum;
    'createdAt': string;
}

export const ApiV1ConversationExportHistoryPost200ResponseInnerStatusEnum = {
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed',
    Cancelled: 'cancelled',
    Expired: 'expired'
} as const;

export type ApiV1ConversationExportHistoryPost200ResponseInnerStatusEnum = typeof ApiV1ConversationExportHistoryPost200ResponseInnerStatusEnum[keyof typeof ApiV1ConversationExportHistoryPost200ResponseInnerStatusEnum];

/**
 * @type ApiV1ConversationExportReadinessPost200Response
 */
export type ApiV1ConversationExportReadinessPost200Response = ApiV1ConversationExportReadinessPost200ResponseOneOf | ApiV1ConversationExportReadinessPost200ResponseOneOf1 | ApiV1ConversationExportReadinessPost200ResponseOneOf2;

export interface ApiV1ConversationExportReadinessPost200ResponseOneOf {
    'status': ApiV1ConversationExportReadinessPost200ResponseOneOfStatusEnum;
    'exportSlugId': string;
    'createdAt': string;
}

export const ApiV1ConversationExportReadinessPost200ResponseOneOfStatusEnum = {
    Active: 'active'
} as const;

export type ApiV1ConversationExportReadinessPost200ResponseOneOfStatusEnum = typeof ApiV1ConversationExportReadinessPost200ResponseOneOfStatusEnum[keyof typeof ApiV1ConversationExportReadinessPost200ResponseOneOfStatusEnum];

export interface ApiV1ConversationExportReadinessPost200ResponseOneOf1 {
    'status': ApiV1ConversationExportReadinessPost200ResponseOneOf1StatusEnum;
    'cooldownEndsAt': string;
    'lastExportSlugId': string;
}

export const ApiV1ConversationExportReadinessPost200ResponseOneOf1StatusEnum = {
    Cooldown: 'cooldown'
} as const;

export type ApiV1ConversationExportReadinessPost200ResponseOneOf1StatusEnum = typeof ApiV1ConversationExportReadinessPost200ResponseOneOf1StatusEnum[keyof typeof ApiV1ConversationExportReadinessPost200ResponseOneOf1StatusEnum];

export interface ApiV1ConversationExportReadinessPost200ResponseOneOf2 {
    'status': ApiV1ConversationExportReadinessPost200ResponseOneOf2StatusEnum;
}

export const ApiV1ConversationExportReadinessPost200ResponseOneOf2StatusEnum = {
    Ready: 'ready'
} as const;

export type ApiV1ConversationExportReadinessPost200ResponseOneOf2StatusEnum = typeof ApiV1ConversationExportReadinessPost200ResponseOneOf2StatusEnum[keyof typeof ApiV1ConversationExportReadinessPost200ResponseOneOf2StatusEnum];

export interface ApiV1ConversationExportRequestPost200Response {
    'success': boolean;
    'status': ApiV1ConversationExportRequestPost200ResponseStatusEnum;
    'exportSlugId': string;
    'cooldownEndsAt': string;
    'reason': ApiV1ConversationExportRequestPost200ResponseReasonEnum;
}

export const ApiV1ConversationExportRequestPost200ResponseStatusEnum = {
    CooldownActive: 'cooldown_active'
} as const;

export type ApiV1ConversationExportRequestPost200ResponseStatusEnum = typeof ApiV1ConversationExportRequestPost200ResponseStatusEnum[keyof typeof ApiV1ConversationExportRequestPost200ResponseStatusEnum];
export const ApiV1ConversationExportRequestPost200ResponseReasonEnum = {
    ActiveExportInProgress: 'active_export_in_progress',
    ConversationNotFound: 'conversation_not_found',
    NoOpinions: 'no_opinions'
} as const;

export type ApiV1ConversationExportRequestPost200ResponseReasonEnum = typeof ApiV1ConversationExportRequestPost200ResponseReasonEnum[keyof typeof ApiV1ConversationExportRequestPost200ResponseReasonEnum];

export interface ApiV1ConversationExportRequestPost200ResponseAnyOf {
    'success': boolean;
    'status': ApiV1ConversationExportRequestPost200ResponseAnyOfStatusEnum;
    'exportSlugId': string;
}

export const ApiV1ConversationExportRequestPost200ResponseAnyOfStatusEnum = {
    Queued: 'queued'
} as const;

export type ApiV1ConversationExportRequestPost200ResponseAnyOfStatusEnum = typeof ApiV1ConversationExportRequestPost200ResponseAnyOfStatusEnum[keyof typeof ApiV1ConversationExportRequestPost200ResponseAnyOfStatusEnum];

export interface ApiV1ConversationExportRequestPost200ResponseAnyOf1 {
    'success': boolean;
    'status': ApiV1ConversationExportRequestPost200ResponseAnyOf1StatusEnum;
    'cooldownEndsAt': string;
}

export const ApiV1ConversationExportRequestPost200ResponseAnyOf1StatusEnum = {
    CooldownActive: 'cooldown_active'
} as const;

export type ApiV1ConversationExportRequestPost200ResponseAnyOf1StatusEnum = typeof ApiV1ConversationExportRequestPost200ResponseAnyOf1StatusEnum[keyof typeof ApiV1ConversationExportRequestPost200ResponseAnyOf1StatusEnum];

export interface ApiV1ConversationExportRequestPost200ResponseAnyOf2 {
    'success': boolean;
    'reason': ApiV1ConversationExportRequestPost200ResponseAnyOf2ReasonEnum;
}

export const ApiV1ConversationExportRequestPost200ResponseAnyOf2ReasonEnum = {
    ActiveExportInProgress: 'active_export_in_progress',
    ConversationNotFound: 'conversation_not_found',
    NoOpinions: 'no_opinions'
} as const;

export type ApiV1ConversationExportRequestPost200ResponseAnyOf2ReasonEnum = typeof ApiV1ConversationExportRequestPost200ResponseAnyOf2ReasonEnum[keyof typeof ApiV1ConversationExportRequestPost200ResponseAnyOf2ReasonEnum];

/**
 * @type ApiV1ConversationExportStatusPost200Response
 */
export type ApiV1ConversationExportStatusPost200Response = ApiV1ConversationExportStatusPost200ResponseOneOf | ApiV1ConversationExportStatusPost200ResponseOneOf1 | ApiV1ConversationExportStatusPost200ResponseOneOf2 | ApiV1ConversationExportStatusPost200ResponseOneOf3 | ApiV1ConversationExportStatusPost200ResponseOneOf4;

export interface ApiV1ConversationExportStatusPost200ResponseOneOf {
    'status': ApiV1ConversationExportStatusPost200ResponseOneOfStatusEnum;
    'exportSlugId': string;
    'conversationSlugId': string;
    'createdAt': string;
    'expiresAt': string;
}

export const ApiV1ConversationExportStatusPost200ResponseOneOfStatusEnum = {
    Processing: 'processing'
} as const;

export type ApiV1ConversationExportStatusPost200ResponseOneOfStatusEnum = typeof ApiV1ConversationExportStatusPost200ResponseOneOfStatusEnum[keyof typeof ApiV1ConversationExportStatusPost200ResponseOneOfStatusEnum];

export interface ApiV1ConversationExportStatusPost200ResponseOneOf1 {
    'status': ApiV1ConversationExportStatusPost200ResponseOneOf1StatusEnum;
    'exportSlugId': string;
    'conversationSlugId': string;
    'files': Array<ApiV1ConversationExportStatusPost200ResponseOneOf1FilesInner>;
    'createdAt': string;
    'expiresAt': string;
}

export const ApiV1ConversationExportStatusPost200ResponseOneOf1StatusEnum = {
    Completed: 'completed'
} as const;

export type ApiV1ConversationExportStatusPost200ResponseOneOf1StatusEnum = typeof ApiV1ConversationExportStatusPost200ResponseOneOf1StatusEnum[keyof typeof ApiV1ConversationExportStatusPost200ResponseOneOf1StatusEnum];

export interface ApiV1ConversationExportStatusPost200ResponseOneOf1FilesInner {
    'fileType': ApiV1ConversationExportStatusPost200ResponseOneOf1FilesInnerFileTypeEnum;
    'fileName': string;
    'fileSize': number;
    'recordCount': number;
    'downloadUrl': string;
    'urlExpiresAt': string;
}

export const ApiV1ConversationExportStatusPost200ResponseOneOf1FilesInnerFileTypeEnum = {
    Comments: 'comments',
    Votes: 'votes',
    Participants: 'participants',
    Summary: 'summary',
    Stats: 'stats'
} as const;

export type ApiV1ConversationExportStatusPost200ResponseOneOf1FilesInnerFileTypeEnum = typeof ApiV1ConversationExportStatusPost200ResponseOneOf1FilesInnerFileTypeEnum[keyof typeof ApiV1ConversationExportStatusPost200ResponseOneOf1FilesInnerFileTypeEnum];

export interface ApiV1ConversationExportStatusPost200ResponseOneOf2 {
    'status': ApiV1ConversationExportStatusPost200ResponseOneOf2StatusEnum;
    'exportSlugId': string;
    'conversationSlugId': string;
    'failureReason'?: ApiV1ConversationExportStatusPost200ResponseOneOf2FailureReasonEnum;
    'createdAt': string;
    'expiresAt': string;
}

export const ApiV1ConversationExportStatusPost200ResponseOneOf2StatusEnum = {
    Failed: 'failed'
} as const;

export type ApiV1ConversationExportStatusPost200ResponseOneOf2StatusEnum = typeof ApiV1ConversationExportStatusPost200ResponseOneOf2StatusEnum[keyof typeof ApiV1ConversationExportStatusPost200ResponseOneOf2StatusEnum];
export const ApiV1ConversationExportStatusPost200ResponseOneOf2FailureReasonEnum = {
    ProcessingError: 'processing_error',
    Timeout: 'timeout',
    ServerRestart: 'server_restart'
} as const;

export type ApiV1ConversationExportStatusPost200ResponseOneOf2FailureReasonEnum = typeof ApiV1ConversationExportStatusPost200ResponseOneOf2FailureReasonEnum[keyof typeof ApiV1ConversationExportStatusPost200ResponseOneOf2FailureReasonEnum];

export interface ApiV1ConversationExportStatusPost200ResponseOneOf3 {
    'status': ApiV1ConversationExportStatusPost200ResponseOneOf3StatusEnum;
    'exportSlugId': string;
    'conversationSlugId': string;
    'cancellationReason': string;
    'createdAt': string;
    'expiresAt': string;
}

export const ApiV1ConversationExportStatusPost200ResponseOneOf3StatusEnum = {
    Cancelled: 'cancelled'
} as const;

export type ApiV1ConversationExportStatusPost200ResponseOneOf3StatusEnum = typeof ApiV1ConversationExportStatusPost200ResponseOneOf3StatusEnum[keyof typeof ApiV1ConversationExportStatusPost200ResponseOneOf3StatusEnum];

export interface ApiV1ConversationExportStatusPost200ResponseOneOf4 {
    'status': ApiV1ConversationExportStatusPost200ResponseOneOf4StatusEnum;
    'exportSlugId': string;
    'conversationSlugId': string;
    'failureReason'?: ApiV1ConversationExportStatusPost200ResponseOneOf4FailureReasonEnum;
    'cancellationReason'?: string;
    'createdAt': string;
    'expiresAt': string;
    'deletedAt': string;
}

export const ApiV1ConversationExportStatusPost200ResponseOneOf4StatusEnum = {
    Expired: 'expired'
} as const;

export type ApiV1ConversationExportStatusPost200ResponseOneOf4StatusEnum = typeof ApiV1ConversationExportStatusPost200ResponseOneOf4StatusEnum[keyof typeof ApiV1ConversationExportStatusPost200ResponseOneOf4StatusEnum];
export const ApiV1ConversationExportStatusPost200ResponseOneOf4FailureReasonEnum = {
    ProcessingError: 'processing_error',
    Timeout: 'timeout',
    ServerRestart: 'server_restart'
} as const;

export type ApiV1ConversationExportStatusPost200ResponseOneOf4FailureReasonEnum = typeof ApiV1ConversationExportStatusPost200ResponseOneOf4FailureReasonEnum[keyof typeof ApiV1ConversationExportStatusPost200ResponseOneOf4FailureReasonEnum];

export interface ApiV1ConversationExportStatusPostRequest {
    'exportSlugId': string;
}
export interface ApiV1ConversationFetchRecentPost200Response {
    'conversationDataList': Array<ApiV1ConversationFetchRecentPost200ResponseConversationDataListInner>;
    'topConversationSlugIdList': Array<string>;
}
export interface ApiV1ConversationFetchRecentPost200ResponseConversationDataListInner {
    'metadata': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadata;
    'payload': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerPayload;
    'interaction': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerInteraction;
}
export interface ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerInteraction {
    'hasVoted': boolean;
    'votedIndex': number;
}
export interface ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadata {
    'conversationSlugId': string;
    'createdAt': string;
    'updatedAt': string;
    'lastReactedAt': string;
    'opinionCount': number;
    'voteCount': number;
    'participantCount': number;
    'authorUsername': string;
    'isLoginRequired': boolean;
    'isIndexed': boolean;
    'isClosed': boolean;
    'organization'?: ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataOrganization;
    'moderation': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModeration;
    'requiresEventTicket'?: ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataRequiresEventTicketEnum;
}

export const ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataRequiresEventTicketEnum = {
    Devconnect2025: 'devconnect-2025'
} as const;

export type ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataRequiresEventTicketEnum = typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataRequiresEventTicketEnum[keyof typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataRequiresEventTicketEnum];

/**
 * @type ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModeration
 */
export type ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModeration = ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf | ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf1;

export interface ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf {
    'status': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfStatusEnum;
    'action': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfActionEnum;
    'reason': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfReasonEnum;
    'explanation': string;
    'createdAt': string;
    'updatedAt': string;
}

export const ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfStatusEnum = {
    Moderated: 'moderated'
} as const;

export type ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfStatusEnum = typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfStatusEnum[keyof typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfStatusEnum];
export const ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfActionEnum = {
    Lock: 'lock'
} as const;

export type ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfActionEnum = typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfActionEnum[keyof typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfActionEnum];
export const ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfReasonEnum = typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfReasonEnum[keyof typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOfReasonEnum];

export interface ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf1 {
    'status': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf1StatusEnum;
}

export const ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf1StatusEnum = {
    Unmoderated: 'unmoderated'
} as const;

export type ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf1StatusEnum = typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf1StatusEnum[keyof typeof ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf1StatusEnum];

export interface ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataOrganization {
    'name': string;
    'imageUrl': string;
    'websiteUrl': string;
    'description': string;
}
export interface ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerPayload {
    'title': string;
    'body'?: string;
    'poll'?: Array<ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerPayloadPollInner>;
}
export interface ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerPayloadPollInner {
    'optionNumber': number;
    'optionTitle': string;
    'numResponses': number;
}
export interface ApiV1ConversationFetchRecentPostRequest {
    'sortAlgorithm': ApiV1ConversationFetchRecentPostRequestSortAlgorithmEnum;
}

export const ApiV1ConversationFetchRecentPostRequestSortAlgorithmEnum = {
    Following: 'following',
    New: 'new'
} as const;

export type ApiV1ConversationFetchRecentPostRequestSortAlgorithmEnum = typeof ApiV1ConversationFetchRecentPostRequestSortAlgorithmEnum[keyof typeof ApiV1ConversationFetchRecentPostRequestSortAlgorithmEnum];

export interface ApiV1ConversationGetPost200Response {
    'conversationData': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInner;
}
/**
 * @type ApiV1ConversationImportActivePost200Response
 */
export type ApiV1ConversationImportActivePost200Response = ApiV1ConversationImportActivePost200ResponseOneOf | ApiV1ConversationImportActivePost200ResponseOneOf1;

export interface ApiV1ConversationImportActivePost200ResponseOneOf {
    'hasActiveImport': boolean;
    'importSlugId': string;
    'createdAt': string;
}
export interface ApiV1ConversationImportActivePost200ResponseOneOf1 {
    'hasActiveImport': boolean;
}
export interface ApiV1ConversationImportPost200Response {
    'importSlugId': string;
}
export interface ApiV1ConversationImportPostRequest {
    'polisUrl': string;
    'postAsOrganization'?: string;
    'indexConversationAt'?: string;
    'isIndexed': boolean;
    'isLoginRequired': boolean;
    'requiresEventTicket'?: ApiV1ConversationImportPostRequestRequiresEventTicketEnum;
}

export const ApiV1ConversationImportPostRequestRequiresEventTicketEnum = {
    Devconnect2025: 'devconnect-2025'
} as const;

export type ApiV1ConversationImportPostRequestRequiresEventTicketEnum = typeof ApiV1ConversationImportPostRequestRequiresEventTicketEnum[keyof typeof ApiV1ConversationImportPostRequestRequiresEventTicketEnum];

/**
 * @type ApiV1ConversationImportStatusPost200Response
 */
export type ApiV1ConversationImportStatusPost200Response = ApiV1ConversationImportStatusPost200ResponseOneOf | ApiV1ConversationImportStatusPost200ResponseOneOf1 | ApiV1ConversationImportStatusPost200ResponseOneOf2;

export interface ApiV1ConversationImportStatusPost200ResponseOneOf {
    'status': ApiV1ConversationImportStatusPost200ResponseOneOfStatusEnum;
    'importSlugId': string;
    'createdAt': string;
    'updatedAt': string;
}

export const ApiV1ConversationImportStatusPost200ResponseOneOfStatusEnum = {
    Processing: 'processing'
} as const;

export type ApiV1ConversationImportStatusPost200ResponseOneOfStatusEnum = typeof ApiV1ConversationImportStatusPost200ResponseOneOfStatusEnum[keyof typeof ApiV1ConversationImportStatusPost200ResponseOneOfStatusEnum];

export interface ApiV1ConversationImportStatusPost200ResponseOneOf1 {
    'status': ApiV1ConversationImportStatusPost200ResponseOneOf1StatusEnum;
    'importSlugId': string;
    'conversationSlugId': string;
    'createdAt': string;
    'updatedAt': string;
}

export const ApiV1ConversationImportStatusPost200ResponseOneOf1StatusEnum = {
    Completed: 'completed'
} as const;

export type ApiV1ConversationImportStatusPost200ResponseOneOf1StatusEnum = typeof ApiV1ConversationImportStatusPost200ResponseOneOf1StatusEnum[keyof typeof ApiV1ConversationImportStatusPost200ResponseOneOf1StatusEnum];

export interface ApiV1ConversationImportStatusPost200ResponseOneOf2 {
    'status': ApiV1ConversationImportStatusPost200ResponseOneOf2StatusEnum;
    'importSlugId': string;
    'failureReason'?: ApiV1ConversationImportStatusPost200ResponseOneOf2FailureReasonEnum;
    'createdAt': string;
    'updatedAt': string;
}

export const ApiV1ConversationImportStatusPost200ResponseOneOf2StatusEnum = {
    Failed: 'failed'
} as const;

export type ApiV1ConversationImportStatusPost200ResponseOneOf2StatusEnum = typeof ApiV1ConversationImportStatusPost200ResponseOneOf2StatusEnum[keyof typeof ApiV1ConversationImportStatusPost200ResponseOneOf2StatusEnum];
export const ApiV1ConversationImportStatusPost200ResponseOneOf2FailureReasonEnum = {
    ProcessingError: 'processing_error',
    Timeout: 'timeout',
    ServerRestart: 'server_restart',
    InvalidDataFormat: 'invalid_data_format'
} as const;

export type ApiV1ConversationImportStatusPost200ResponseOneOf2FailureReasonEnum = typeof ApiV1ConversationImportStatusPost200ResponseOneOf2FailureReasonEnum[keyof typeof ApiV1ConversationImportStatusPost200ResponseOneOf2FailureReasonEnum];

export interface ApiV1ConversationImportStatusPostRequest {
    'importSlugId': string;
}
/**
 * @type ApiV1ConversationOpenPost200Response
 */
export type ApiV1ConversationOpenPost200Response = ApiV1ConversationClosePost200ResponseOneOf | ApiV1ConversationOpenPost200ResponseOneOf;

export interface ApiV1ConversationOpenPost200ResponseOneOf {
    'success': boolean;
    'reason': ApiV1ConversationOpenPost200ResponseOneOfReasonEnum;
}

export const ApiV1ConversationOpenPost200ResponseOneOfReasonEnum = {
    NotAllowed: 'not_allowed',
    AlreadyOpen: 'already_open'
} as const;

export type ApiV1ConversationOpenPost200ResponseOneOfReasonEnum = typeof ApiV1ConversationOpenPost200ResponseOneOfReasonEnum[keyof typeof ApiV1ConversationOpenPost200ResponseOneOfReasonEnum];

export interface ApiV1ConversationValidateCsvPost200Response {
    'summaryFile'?: ApiV1ConversationValidateCsvPost200ResponseSummaryFile;
    'commentsFile'?: ApiV1ConversationValidateCsvPost200ResponseSummaryFile;
    'votesFile'?: ApiV1ConversationValidateCsvPost200ResponseSummaryFile;
}
export interface ApiV1ConversationValidateCsvPost200ResponseSummaryFile {
    'isValid': boolean;
    'error'?: string;
}
export interface ApiV1ModerationConversationCreatePostRequest {
    'conversationSlugId': string;
    'moderationReason': ApiV1ModerationConversationCreatePostRequestModerationReasonEnum;
    'moderationAction': ApiV1ModerationConversationCreatePostRequestModerationActionEnum;
    'moderationExplanation': string;
}

export const ApiV1ModerationConversationCreatePostRequestModerationReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ModerationConversationCreatePostRequestModerationReasonEnum = typeof ApiV1ModerationConversationCreatePostRequestModerationReasonEnum[keyof typeof ApiV1ModerationConversationCreatePostRequestModerationReasonEnum];
export const ApiV1ModerationConversationCreatePostRequestModerationActionEnum = {
    Lock: 'lock'
} as const;

export type ApiV1ModerationConversationCreatePostRequestModerationActionEnum = typeof ApiV1ModerationConversationCreatePostRequestModerationActionEnum[keyof typeof ApiV1ModerationConversationCreatePostRequestModerationActionEnum];

export interface ApiV1ModerationConversationGetPostRequest {
    'conversationSlugId': string;
}
export interface ApiV1ModerationConversationWithdrawPostRequest {
    'conversationSlugId': string;
}
export interface ApiV1ModerationOpinionCreatePostRequest {
    'opinionSlugId': string;
    'moderationReason': ApiV1ModerationOpinionCreatePostRequestModerationReasonEnum;
    'moderationAction': ApiV1ModerationOpinionCreatePostRequestModerationActionEnum;
    'moderationExplanation': string;
}

export const ApiV1ModerationOpinionCreatePostRequestModerationReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ModerationOpinionCreatePostRequestModerationReasonEnum = typeof ApiV1ModerationOpinionCreatePostRequestModerationReasonEnum[keyof typeof ApiV1ModerationOpinionCreatePostRequestModerationReasonEnum];
export const ApiV1ModerationOpinionCreatePostRequestModerationActionEnum = {
    Move: 'move',
    Hide: 'hide'
} as const;

export type ApiV1ModerationOpinionCreatePostRequestModerationActionEnum = typeof ApiV1ModerationOpinionCreatePostRequestModerationActionEnum[keyof typeof ApiV1ModerationOpinionCreatePostRequestModerationActionEnum];

/**
 * @type ApiV1ModerationOpinionGetPost200Response
 */
export type ApiV1ModerationOpinionGetPost200Response = ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModerationOneOf1 | ApiV1ModerationOpinionGetPost200ResponseOneOf;

export interface ApiV1ModerationOpinionGetPost200ResponseOneOf {
    'status': ApiV1ModerationOpinionGetPost200ResponseOneOfStatusEnum;
    'action': ApiV1ModerationOpinionGetPost200ResponseOneOfActionEnum;
    'reason': ApiV1ModerationOpinionGetPost200ResponseOneOfReasonEnum;
    'explanation': string;
    'createdAt': string;
    'updatedAt': string;
}

export const ApiV1ModerationOpinionGetPost200ResponseOneOfStatusEnum = {
    Moderated: 'moderated'
} as const;

export type ApiV1ModerationOpinionGetPost200ResponseOneOfStatusEnum = typeof ApiV1ModerationOpinionGetPost200ResponseOneOfStatusEnum[keyof typeof ApiV1ModerationOpinionGetPost200ResponseOneOfStatusEnum];
export const ApiV1ModerationOpinionGetPost200ResponseOneOfActionEnum = {
    Move: 'move',
    Hide: 'hide'
} as const;

export type ApiV1ModerationOpinionGetPost200ResponseOneOfActionEnum = typeof ApiV1ModerationOpinionGetPost200ResponseOneOfActionEnum[keyof typeof ApiV1ModerationOpinionGetPost200ResponseOneOfActionEnum];
export const ApiV1ModerationOpinionGetPost200ResponseOneOfReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ModerationOpinionGetPost200ResponseOneOfReasonEnum = typeof ApiV1ModerationOpinionGetPost200ResponseOneOfReasonEnum[keyof typeof ApiV1ModerationOpinionGetPost200ResponseOneOfReasonEnum];

export interface ApiV1ModerationOpinionWithdrawPostRequest {
    'opinionSlugId': string;
}
export interface ApiV1MuteUserCreatePostRequest {
    'targetUsername': string;
    'action': ApiV1MuteUserCreatePostRequestActionEnum;
}

export const ApiV1MuteUserCreatePostRequestActionEnum = {
    Mute: 'mute',
    Unmute: 'unmute'
} as const;

export type ApiV1MuteUserCreatePostRequestActionEnum = typeof ApiV1MuteUserCreatePostRequestActionEnum[keyof typeof ApiV1MuteUserCreatePostRequestActionEnum];

export interface ApiV1MuteUserGetPost200ResponseInner {
    'createdAt': string;
    'username': string;
}
export interface ApiV1NotificationFetchPost200Response {
    'numNewNotifications': number;
    'notificationList': Array<ApiV1NotificationFetchPost200ResponseNotificationListInner>;
}
/**
 * @type ApiV1NotificationFetchPost200ResponseNotificationListInner
 */
export type ApiV1NotificationFetchPost200ResponseNotificationListInner = ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf | ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf1 | ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2 | ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf3 | ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4 | ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf5 | ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6 | ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf7 | ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8;

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf {
    'slugId': string;
    'isRead': boolean;
    'createdAt': string;
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfTypeEnum;
    'routeTarget': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfRouteTarget;
    'numVotes': number;
    'message': string;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfTypeEnum = {
    OpinionVote: 'opinion_vote'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfTypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfTypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfTypeEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf1 {
    'slugId': string;
    'isRead': boolean;
    'createdAt': string;
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf1TypeEnum;
    'routeTarget': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfRouteTarget;
    'username': string;
    'message': string;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf1TypeEnum = {
    NewOpinion: 'new_opinion'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf1TypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf1TypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf1TypeEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2 {
    'slugId': string;
    'isRead': boolean;
    'createdAt': string;
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2TypeEnum;
    'routeTarget': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTarget;
    'conversationTitle': string;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2TypeEnum = {
    ExportStarted: 'export_started'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2TypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2TypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2TypeEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTarget {
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTargetTypeEnum;
    'conversationSlugId': string;
    'exportSlugId': string;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTargetTypeEnum = {
    Export: 'export'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTargetTypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTargetTypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTargetTypeEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf3 {
    'slugId': string;
    'isRead': boolean;
    'createdAt': string;
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf3TypeEnum;
    'routeTarget': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTarget;
    'conversationTitle': string;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf3TypeEnum = {
    ExportCompleted: 'export_completed'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf3TypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf3TypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf3TypeEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4 {
    'slugId': string;
    'isRead': boolean;
    'createdAt': string;
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4TypeEnum;
    'routeTarget': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTarget;
    'conversationTitle': string;
    'failureReason'?: ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4FailureReasonEnum;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4TypeEnum = {
    ExportFailed: 'export_failed'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4TypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4TypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4TypeEnum];
export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4FailureReasonEnum = {
    ProcessingError: 'processing_error',
    Timeout: 'timeout',
    ServerRestart: 'server_restart'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4FailureReasonEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4FailureReasonEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf4FailureReasonEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf5 {
    'slugId': string;
    'isRead': boolean;
    'createdAt': string;
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf5TypeEnum;
    'routeTarget': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf2RouteTarget;
    'conversationTitle': string;
    'cancellationReason': string;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf5TypeEnum = {
    ExportCancelled: 'export_cancelled'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf5TypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf5TypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf5TypeEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6 {
    'slugId': string;
    'isRead': boolean;
    'createdAt': string;
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6TypeEnum;
    'routeTarget': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6RouteTarget;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6TypeEnum = {
    ImportStarted: 'import_started'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6TypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6TypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6TypeEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6RouteTarget {
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6RouteTargetTypeEnum;
    'importSlugId': string;
    'conversationSlugId'?: string;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6RouteTargetTypeEnum = {
    Import: 'import'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6RouteTargetTypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6RouteTargetTypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6RouteTargetTypeEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf7 {
    'slugId': string;
    'isRead': boolean;
    'createdAt': string;
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf7TypeEnum;
    'routeTarget': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6RouteTarget;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf7TypeEnum = {
    ImportCompleted: 'import_completed'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf7TypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf7TypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf7TypeEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8 {
    'slugId': string;
    'isRead': boolean;
    'createdAt': string;
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8TypeEnum;
    'routeTarget': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf6RouteTarget;
    'failureReason'?: ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8FailureReasonEnum;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8TypeEnum = {
    ImportFailed: 'import_failed'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8TypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8TypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8TypeEnum];
export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8FailureReasonEnum = {
    ProcessingError: 'processing_error',
    Timeout: 'timeout',
    ServerRestart: 'server_restart',
    InvalidDataFormat: 'invalid_data_format'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8FailureReasonEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8FailureReasonEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOf8FailureReasonEnum];

export interface ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfRouteTarget {
    'type': ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfRouteTargetTypeEnum;
    'conversationSlugId': string;
    'opinionSlugId': string;
}

export const ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfRouteTargetTypeEnum = {
    Opinion: 'opinion'
} as const;

export type ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfRouteTargetTypeEnum = typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfRouteTargetTypeEnum[keyof typeof ApiV1NotificationFetchPost200ResponseNotificationListInnerOneOfRouteTargetTypeEnum];

export interface ApiV1NotificationFetchPostRequest {
    'lastSlugId'?: string;
}
/**
 * @type ApiV1OpinionCreatePost200Response
 */
export type ApiV1OpinionCreatePost200Response = ApiV1OpinionCreatePost200ResponseOneOf | ApiV1VoteCastPost200ResponseOneOf1;

export interface ApiV1OpinionCreatePost200ResponseOneOf {
    'success': boolean;
    'opinionSlugId': string;
}
export interface ApiV1OpinionCreatePostRequest {
    'conversationSlugId': string;
    'opinionBody': string;
}
export interface ApiV1OpinionFetchAnalysisByConversationPost200Response {
    'polisContentId'?: number;
    'consensus': Array<ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInner>;
    'controversial': Array<ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInner>;
    'clusters': { [key: string]: ApiV1OpinionFetchAnalysisByConversationPost200ResponseClustersValue; };
}
export interface ApiV1OpinionFetchAnalysisByConversationPost200ResponseClustersValue {
    'key': ApiV1OpinionFetchAnalysisByConversationPost200ResponseClustersValueKeyEnum;
    'numUsers': number;
    'aiLabel'?: string;
    'aiSummary'?: string;
    'isUserInCluster': boolean;
    'representative': Array<ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInner>;
}

export const ApiV1OpinionFetchAnalysisByConversationPost200ResponseClustersValueKeyEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5'
} as const;

export type ApiV1OpinionFetchAnalysisByConversationPost200ResponseClustersValueKeyEnum = typeof ApiV1OpinionFetchAnalysisByConversationPost200ResponseClustersValueKeyEnum[keyof typeof ApiV1OpinionFetchAnalysisByConversationPost200ResponseClustersValueKeyEnum];

export interface ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInner {
    'opinionSlugId': string;
    'createdAt': string;
    'updatedAt': string;
    'opinion': string;
    'numParticipants': number;
    'numAgrees': number;
    'numDisagrees': number;
    'numPasses': number;
    'username': string;
    'moderation': ApiV1ModerationOpinionGetPost200Response;
    'isSeed': boolean;
    'clustersStats': Array<ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInnerClustersStatsInner>;
}
export interface ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInnerClustersStatsInner {
    'key': ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInnerClustersStatsInnerKeyEnum;
    'isAuthorInCluster': boolean;
    'numUsers': number;
    'numAgrees': number;
    'numDisagrees': number;
    'numPasses': number;
}

export const ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInnerClustersStatsInnerKeyEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5'
} as const;

export type ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInnerClustersStatsInnerKeyEnum = typeof ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInnerClustersStatsInnerKeyEnum[keyof typeof ApiV1OpinionFetchAnalysisByConversationPost200ResponseConsensusInnerClustersStatsInnerKeyEnum];

export interface ApiV1OpinionFetchByConversationPostRequest {
    'conversationSlugId': string;
    'filter': ApiV1OpinionFetchByConversationPostRequestFilterEnum;
    'clusterKey'?: ApiV1OpinionFetchByConversationPostRequestClusterKeyEnum;
}

export const ApiV1OpinionFetchByConversationPostRequestFilterEnum = {
    Hidden: 'hidden',
    Moderated: 'moderated',
    New: 'new',
    Discover: 'discover',
    MyVotes: 'my_votes'
} as const;

export type ApiV1OpinionFetchByConversationPostRequestFilterEnum = typeof ApiV1OpinionFetchByConversationPostRequestFilterEnum[keyof typeof ApiV1OpinionFetchByConversationPostRequestFilterEnum];
export const ApiV1OpinionFetchByConversationPostRequestClusterKeyEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5'
} as const;

export type ApiV1OpinionFetchByConversationPostRequestClusterKeyEnum = typeof ApiV1OpinionFetchByConversationPostRequestClusterKeyEnum[keyof typeof ApiV1OpinionFetchByConversationPostRequestClusterKeyEnum];

export interface ApiV1OpinionFetchBySlugIdListPostRequest {
    'opinionSlugIdList': Array<string>;
}
export interface ApiV1OpinionFetchHiddenByConversationPostRequest {
    'conversationSlugId': string;
    'createdAt'?: string;
}
export interface ApiV1PollRespondPostRequest {
    'voteOptionChoice': number;
    'conversationSlugId': string;
}
export interface ApiV1ReportConversationCreatePostRequest {
    'conversationSlugId': string;
    'reportReason': ApiV1ReportConversationCreatePostRequestReportReasonEnum;
    'reportExplanation'?: string;
}

export const ApiV1ReportConversationCreatePostRequestReportReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ReportConversationCreatePostRequestReportReasonEnum = typeof ApiV1ReportConversationCreatePostRequestReportReasonEnum[keyof typeof ApiV1ReportConversationCreatePostRequestReportReasonEnum];

export interface ApiV1ReportConversationFetchPost200ResponseInner {
    'username': string;
    'reason': ApiV1ReportConversationFetchPost200ResponseInnerReasonEnum;
    'explanation'?: string;
    'createdAt': string;
    'id': number;
}

export const ApiV1ReportConversationFetchPost200ResponseInnerReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ReportConversationFetchPost200ResponseInnerReasonEnum = typeof ApiV1ReportConversationFetchPost200ResponseInnerReasonEnum[keyof typeof ApiV1ReportConversationFetchPost200ResponseInnerReasonEnum];

export interface ApiV1ReportOpinionCreatePostRequest {
    'opinionSlugId': string;
    'reportReason': ApiV1ReportOpinionCreatePostRequestReportReasonEnum;
    'reportExplanation'?: string;
}

export const ApiV1ReportOpinionCreatePostRequestReportReasonEnum = {
    Misleading: 'misleading',
    Antisocial: 'antisocial',
    Illegal: 'illegal',
    Doxing: 'doxing',
    Sexual: 'sexual',
    Spam: 'spam'
} as const;

export type ApiV1ReportOpinionCreatePostRequestReportReasonEnum = typeof ApiV1ReportOpinionCreatePostRequestReportReasonEnum[keyof typeof ApiV1ReportOpinionCreatePostRequestReportReasonEnum];

export interface ApiV1TopicFollowPostRequest {
    'topicCode': string;
}
export interface ApiV1TopicGetAllTopicsPost200Response {
    'topicList': Array<ApiV1TopicGetAllTopicsPost200ResponseTopicListInner>;
}
export interface ApiV1TopicGetAllTopicsPost200ResponseTopicListInner {
    'code': string;
    'name': string;
}
export interface ApiV1TopicGetFollowedPost200Response {
    'followedTopicCodeList': Array<string>;
}
export interface ApiV1UserConversationFetchPostRequest {
    'lastConversationSlugId'?: string;
}
export interface ApiV1UserLanguagePreferencesGetPost200Response {
    'spokenLanguages': Array<ApiV1UserLanguagePreferencesGetPost200ResponseSpokenLanguagesEnum>;
    'displayLanguage': ApiV1UserLanguagePreferencesGetPost200ResponseDisplayLanguageEnum;
}

export const ApiV1UserLanguagePreferencesGetPost200ResponseSpokenLanguagesEnum = {
    En: 'en',
    Es: 'es',
    Fr: 'fr',
    EnGb: 'en-GB',
    Ar: 'ar',
    Bn: 'bn',
    Eu: 'eu',
    Bg: 'bg',
    Ca: 'ca',
    Hr: 'hr',
    Cs: 'cs',
    Da: 'da',
    Nl: 'nl',
    Fil: 'fil',
    Fi: 'fi',
    Gl: 'gl',
    De: 'de',
    El: 'el',
    Gu: 'gu',
    He: 'he',
    Hi: 'hi',
    Hu: 'hu',
    Id: 'id',
    Ga: 'ga',
    It: 'it',
    Ja: 'ja',
    Kn: 'kn',
    Ko: 'ko',
    Ms: 'ms',
    Mr: 'mr',
    No: 'no',
    Fa: 'fa',
    Pl: 'pl',
    Pt: 'pt',
    Ro: 'ro',
    Ru: 'ru',
    Sr: 'sr',
    Sk: 'sk',
    Sv: 'sv',
    Ta: 'ta',
    Th: 'th',
    Tr: 'tr',
    Uk: 'uk',
    Ur: 'ur',
    Vi: 'vi',
    ZhHans: 'zh-Hans',
    ZhHant: 'zh-Hant'
} as const;

export type ApiV1UserLanguagePreferencesGetPost200ResponseSpokenLanguagesEnum = typeof ApiV1UserLanguagePreferencesGetPost200ResponseSpokenLanguagesEnum[keyof typeof ApiV1UserLanguagePreferencesGetPost200ResponseSpokenLanguagesEnum];
export const ApiV1UserLanguagePreferencesGetPost200ResponseDisplayLanguageEnum = {
    En: 'en',
    Es: 'es',
    Fr: 'fr',
    ZhHant: 'zh-Hant',
    ZhHans: 'zh-Hans',
    Ja: 'ja',
    Ar: 'ar'
} as const;

export type ApiV1UserLanguagePreferencesGetPost200ResponseDisplayLanguageEnum = typeof ApiV1UserLanguagePreferencesGetPost200ResponseDisplayLanguageEnum[keyof typeof ApiV1UserLanguagePreferencesGetPost200ResponseDisplayLanguageEnum];

export interface ApiV1UserLanguagePreferencesGetPostRequest {
    'currentDisplayLanguage': ApiV1UserLanguagePreferencesGetPostRequestCurrentDisplayLanguageEnum;
}

export const ApiV1UserLanguagePreferencesGetPostRequestCurrentDisplayLanguageEnum = {
    En: 'en',
    Es: 'es',
    Fr: 'fr',
    ZhHant: 'zh-Hant',
    ZhHans: 'zh-Hans',
    Ja: 'ja',
    Ar: 'ar'
} as const;

export type ApiV1UserLanguagePreferencesGetPostRequestCurrentDisplayLanguageEnum = typeof ApiV1UserLanguagePreferencesGetPostRequestCurrentDisplayLanguageEnum[keyof typeof ApiV1UserLanguagePreferencesGetPostRequestCurrentDisplayLanguageEnum];

export interface ApiV1UserLanguagePreferencesUpdatePostRequest {
    'spokenLanguages'?: Array<ApiV1UserLanguagePreferencesUpdatePostRequestSpokenLanguagesEnum>;
    'displayLanguage'?: ApiV1UserLanguagePreferencesUpdatePostRequestDisplayLanguageEnum;
}

export const ApiV1UserLanguagePreferencesUpdatePostRequestSpokenLanguagesEnum = {
    En: 'en',
    Es: 'es',
    Fr: 'fr',
    EnGb: 'en-GB',
    Ar: 'ar',
    Bn: 'bn',
    Eu: 'eu',
    Bg: 'bg',
    Ca: 'ca',
    Hr: 'hr',
    Cs: 'cs',
    Da: 'da',
    Nl: 'nl',
    Fil: 'fil',
    Fi: 'fi',
    Gl: 'gl',
    De: 'de',
    El: 'el',
    Gu: 'gu',
    He: 'he',
    Hi: 'hi',
    Hu: 'hu',
    Id: 'id',
    Ga: 'ga',
    It: 'it',
    Ja: 'ja',
    Kn: 'kn',
    Ko: 'ko',
    Ms: 'ms',
    Mr: 'mr',
    No: 'no',
    Fa: 'fa',
    Pl: 'pl',
    Pt: 'pt',
    Ro: 'ro',
    Ru: 'ru',
    Sr: 'sr',
    Sk: 'sk',
    Sv: 'sv',
    Ta: 'ta',
    Th: 'th',
    Tr: 'tr',
    Uk: 'uk',
    Ur: 'ur',
    Vi: 'vi',
    ZhHans: 'zh-Hans',
    ZhHant: 'zh-Hant'
} as const;

export type ApiV1UserLanguagePreferencesUpdatePostRequestSpokenLanguagesEnum = typeof ApiV1UserLanguagePreferencesUpdatePostRequestSpokenLanguagesEnum[keyof typeof ApiV1UserLanguagePreferencesUpdatePostRequestSpokenLanguagesEnum];
export const ApiV1UserLanguagePreferencesUpdatePostRequestDisplayLanguageEnum = {
    En: 'en',
    Es: 'es',
    Fr: 'fr',
    ZhHant: 'zh-Hant',
    ZhHans: 'zh-Hans',
    Ja: 'ja',
    Ar: 'ar'
} as const;

export type ApiV1UserLanguagePreferencesUpdatePostRequestDisplayLanguageEnum = typeof ApiV1UserLanguagePreferencesUpdatePostRequestDisplayLanguageEnum[keyof typeof ApiV1UserLanguagePreferencesUpdatePostRequestDisplayLanguageEnum];

export interface ApiV1UserOpinionFetchPost200ResponseInner {
    'conversationData': ApiV1ConversationFetchRecentPost200ResponseConversationDataListInner;
    'opinionItem': ApiV1UserOpinionFetchPost200ResponseInnerOpinionItem;
}
export interface ApiV1UserOpinionFetchPost200ResponseInnerOpinionItem {
    'opinionSlugId': string;
    'createdAt': string;
    'updatedAt': string;
    'opinion': string;
    'numParticipants': number;
    'numAgrees': number;
    'numDisagrees': number;
    'numPasses': number;
    'username': string;
    'moderation': ApiV1ModerationOpinionGetPost200Response;
    'isSeed': boolean;
}
export interface ApiV1UserOpinionFetchPostRequest {
    'lastOpinionSlugId'?: string;
}
export interface ApiV1UserPollGetResponseByConversationsPost200ResponseInner {
    'conversationSlugId': string;
    'optionChosen': number;
}
export interface ApiV1UserProfileGetPost200Response {
    'activePostCount': number;
    'createdAt': string;
    'username': string;
    'isModerator': boolean;
    'organizationList': Array<ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataOrganization>;
    'verifiedEventTickets': Array<ApiV1UserProfileGetPost200ResponseVerifiedEventTicketsEnum>;
}

export const ApiV1UserProfileGetPost200ResponseVerifiedEventTicketsEnum = {
    Devconnect2025: 'devconnect-2025'
} as const;

export type ApiV1UserProfileGetPost200ResponseVerifiedEventTicketsEnum = typeof ApiV1UserProfileGetPost200ResponseVerifiedEventTicketsEnum[keyof typeof ApiV1UserProfileGetPost200ResponseVerifiedEventTicketsEnum];

export interface ApiV1UserUsernameUpdatePostRequest {
    'username': string;
}
export interface ApiV1UserVoteGetByConversationsPost200ResponseInner {
    'opinionSlugId': string;
    'votingAction': ApiV1UserVoteGetByConversationsPost200ResponseInnerVotingActionEnum;
}

export const ApiV1UserVoteGetByConversationsPost200ResponseInnerVotingActionEnum = {
    Agree: 'agree',
    Disagree: 'disagree',
    Pass: 'pass'
} as const;

export type ApiV1UserVoteGetByConversationsPost200ResponseInnerVotingActionEnum = typeof ApiV1UserVoteGetByConversationsPost200ResponseInnerVotingActionEnum[keyof typeof ApiV1UserVoteGetByConversationsPost200ResponseInnerVotingActionEnum];

export interface ApiV1UserVoteGetByConversationsPostRequest {
    'conversationSlugIdList': Array<string>;
}
/**
 * @type ApiV1VoteCastPost200Response
 */
export type ApiV1VoteCastPost200Response = ApiV1VoteCastPost200ResponseOneOf | ApiV1VoteCastPost200ResponseOneOf1;

export interface ApiV1VoteCastPost200ResponseOneOf {
    'success': boolean;
    'userIsClustered'?: boolean;
}
export interface ApiV1VoteCastPost200ResponseOneOf1 {
    'success': boolean;
    'reason': ApiV1VoteCastPost200ResponseOneOf1ReasonEnum;
}

export const ApiV1VoteCastPost200ResponseOneOf1ReasonEnum = {
    ConversationLocked: 'conversation_locked',
    ConversationClosed: 'conversation_closed',
    EventTicketRequired: 'event_ticket_required'
} as const;

export type ApiV1VoteCastPost200ResponseOneOf1ReasonEnum = typeof ApiV1VoteCastPost200ResponseOneOf1ReasonEnum[keyof typeof ApiV1VoteCastPost200ResponseOneOf1ReasonEnum];

export interface ApiV1VoteCastPostRequest {
    'opinionSlugId': string;
    'chosenOption': ApiV1VoteCastPostRequestChosenOptionEnum;
    'returnIsUserClustered'?: boolean;
}

export const ApiV1VoteCastPostRequestChosenOptionEnum = {
    Agree: 'agree',
    Disagree: 'disagree',
    Pass: 'pass',
    Cancel: 'cancel'
} as const;

export type ApiV1VoteCastPostRequestChosenOptionEnum = typeof ApiV1VoteCastPostRequestChosenOptionEnum[keyof typeof ApiV1VoteCastPostRequestChosenOptionEnum];


/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountGenerateUnusedRandomUsernamePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/generate-unused-random-username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountIsUsernameInUsePost: async (apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UserUsernameUpdatePostRequest' is not null or undefined
            assertParamExists('apiV1AccountIsUsernameInUsePost', 'apiV1UserUsernameUpdatePostRequest', apiV1UserUsernameUpdatePostRequest)
            const localVarPath = `/api/v1/account/is-username-in-use`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserUsernameUpdatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest} apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationAddUserOrganizationMappingPost: async (apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest: ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest' is not null or undefined
            assertParamExists('apiV1AdministratorOrganizationAddUserOrganizationMappingPost', 'apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest', apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest)
            const localVarPath = `/api/v1/administrator/organization/add-user-organization-mapping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationCreateOrganizationPostRequest} apiV1AdministratorOrganizationCreateOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationCreateOrganizationPost: async (apiV1AdministratorOrganizationCreateOrganizationPostRequest: ApiV1AdministratorOrganizationCreateOrganizationPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AdministratorOrganizationCreateOrganizationPostRequest' is not null or undefined
            assertParamExists('apiV1AdministratorOrganizationCreateOrganizationPost', 'apiV1AdministratorOrganizationCreateOrganizationPostRequest', apiV1AdministratorOrganizationCreateOrganizationPostRequest)
            const localVarPath = `/api/v1/administrator/organization/create-organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AdministratorOrganizationCreateOrganizationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationDeleteOrganizationPostRequest} apiV1AdministratorOrganizationDeleteOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationDeleteOrganizationPost: async (apiV1AdministratorOrganizationDeleteOrganizationPostRequest: ApiV1AdministratorOrganizationDeleteOrganizationPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AdministratorOrganizationDeleteOrganizationPostRequest' is not null or undefined
            assertParamExists('apiV1AdministratorOrganizationDeleteOrganizationPost', 'apiV1AdministratorOrganizationDeleteOrganizationPostRequest', apiV1AdministratorOrganizationDeleteOrganizationPostRequest)
            const localVarPath = `/api/v1/administrator/organization/delete-organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AdministratorOrganizationDeleteOrganizationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationGetAllOrganizationsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/administrator/organization/get-all-organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost: async (apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UserUsernameUpdatePostRequest' is not null or undefined
            assertParamExists('apiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost', 'apiV1UserUsernameUpdatePostRequest', apiV1UserUsernameUpdatePostRequest)
            const localVarPath = `/api/v1/administrator/organization/get-organization-names-by-username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserUsernameUpdatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest} apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationRemoveUserOrganizationMappingPost: async (apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest: ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest' is not null or undefined
            assertParamExists('apiV1AdministratorOrganizationRemoveUserOrganizationMappingPost', 'apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest', apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest)
            const localVarPath = `/api/v1/administrator/organization/remove-user-organization-mapping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AuthAuthenticatePostRequest} apiV1AuthAuthenticatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAuthenticatePost: async (apiV1AuthAuthenticatePostRequest: ApiV1AuthAuthenticatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AuthAuthenticatePostRequest' is not null or undefined
            assertParamExists('apiV1AuthAuthenticatePost', 'apiV1AuthAuthenticatePostRequest', apiV1AuthAuthenticatePostRequest)
            const localVarPath = `/api/v1/auth/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AuthAuthenticatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthCheckLoginStatusPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/check-login-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AuthPhoneVerifyOtpPostRequest} apiV1AuthPhoneVerifyOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthPhoneVerifyOtpPost: async (apiV1AuthPhoneVerifyOtpPostRequest: ApiV1AuthPhoneVerifyOtpPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AuthPhoneVerifyOtpPostRequest' is not null or undefined
            assertParamExists('apiV1AuthPhoneVerifyOtpPost', 'apiV1AuthPhoneVerifyOtpPostRequest', apiV1AuthPhoneVerifyOtpPostRequest)
            const localVarPath = `/api/v1/auth/phone/verify-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AuthPhoneVerifyOtpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AuthTicketVerifyPostRequest} apiV1AuthTicketVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTicketVerifyPost: async (apiV1AuthTicketVerifyPostRequest: ApiV1AuthTicketVerifyPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AuthTicketVerifyPostRequest' is not null or undefined
            assertParamExists('apiV1AuthTicketVerifyPost', 'apiV1AuthTicketVerifyPostRequest', apiV1AuthTicketVerifyPostRequest)
            const localVarPath = `/api/v1/auth/ticket/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AuthTicketVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1AuthZkpGenerateVerificationLinkPostRequest} apiV1AuthZkpGenerateVerificationLinkPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthZkpGenerateVerificationLinkPost: async (apiV1AuthZkpGenerateVerificationLinkPostRequest: ApiV1AuthZkpGenerateVerificationLinkPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1AuthZkpGenerateVerificationLinkPostRequest' is not null or undefined
            assertParamExists('apiV1AuthZkpGenerateVerificationLinkPost', 'apiV1AuthZkpGenerateVerificationLinkPostRequest', apiV1AuthZkpGenerateVerificationLinkPostRequest)
            const localVarPath = `/api/v1/auth/zkp/generate-verification-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AuthZkpGenerateVerificationLinkPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthZkpVerifyUserStatusAndAuthenticatePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/zkp/verify-user-status-and-authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationClosePost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationClosePost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/conversation/close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ConversationCreatePostRequest} apiV1ConversationCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationCreatePost: async (apiV1ConversationCreatePostRequest: ApiV1ConversationCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ConversationCreatePostRequest' is not null or undefined
            assertParamExists('apiV1ConversationCreatePost', 'apiV1ConversationCreatePostRequest', apiV1ConversationCreatePostRequest)
            const localVarPath = `/api/v1/conversation/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ConversationCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationDeletePost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationDeletePost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/conversation/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ConversationExportStatusPostRequest} apiV1ConversationExportStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportDeletePost: async (apiV1ConversationExportStatusPostRequest: ApiV1ConversationExportStatusPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ConversationExportStatusPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationExportDeletePost', 'apiV1ConversationExportStatusPostRequest', apiV1ConversationExportStatusPostRequest)
            const localVarPath = `/api/v1/conversation/export/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ConversationExportStatusPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportHistoryPost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationExportHistoryPost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/conversation/export/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportReadinessPost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationExportReadinessPost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/conversation/export/readiness`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportRequestPost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationExportRequestPost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/conversation/export/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ConversationExportStatusPostRequest} apiV1ConversationExportStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportStatusPost: async (apiV1ConversationExportStatusPostRequest: ApiV1ConversationExportStatusPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ConversationExportStatusPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationExportStatusPost', 'apiV1ConversationExportStatusPostRequest', apiV1ConversationExportStatusPostRequest)
            const localVarPath = `/api/v1/conversation/export/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ConversationExportStatusPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ConversationFetchRecentPostRequest} apiV1ConversationFetchRecentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationFetchRecentPost: async (apiV1ConversationFetchRecentPostRequest: ApiV1ConversationFetchRecentPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ConversationFetchRecentPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationFetchRecentPost', 'apiV1ConversationFetchRecentPostRequest', apiV1ConversationFetchRecentPostRequest)
            const localVarPath = `/api/v1/conversation/fetch-recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ConversationFetchRecentPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationGetPost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationGetPost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/conversation/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationImportActivePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/conversation/import/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationImportCsvPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/conversation/import-csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ConversationImportPostRequest} apiV1ConversationImportPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationImportPost: async (apiV1ConversationImportPostRequest: ApiV1ConversationImportPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ConversationImportPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationImportPost', 'apiV1ConversationImportPostRequest', apiV1ConversationImportPostRequest)
            const localVarPath = `/api/v1/conversation/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ConversationImportPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ConversationImportStatusPostRequest} apiV1ConversationImportStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationImportStatusPost: async (apiV1ConversationImportStatusPostRequest: ApiV1ConversationImportStatusPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ConversationImportStatusPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationImportStatusPost', 'apiV1ConversationImportStatusPostRequest', apiV1ConversationImportStatusPostRequest)
            const localVarPath = `/api/v1/conversation/import/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ConversationImportStatusPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationOpenPost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ConversationOpenPost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/conversation/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationValidateCsvPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/conversation/validate-csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationCreatePostRequest} apiV1ModerationConversationCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationConversationCreatePost: async (apiV1ModerationConversationCreatePostRequest: ApiV1ModerationConversationCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationCreatePostRequest' is not null or undefined
            assertParamExists('apiV1ModerationConversationCreatePost', 'apiV1ModerationConversationCreatePostRequest', apiV1ModerationConversationCreatePostRequest)
            const localVarPath = `/api/v1/moderation/conversation/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationGetPostRequest} apiV1ModerationConversationGetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationConversationGetPost: async (apiV1ModerationConversationGetPostRequest: ApiV1ModerationConversationGetPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationGetPostRequest' is not null or undefined
            assertParamExists('apiV1ModerationConversationGetPost', 'apiV1ModerationConversationGetPostRequest', apiV1ModerationConversationGetPostRequest)
            const localVarPath = `/api/v1/moderation/conversation/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationGetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationConversationWithdrawPost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ModerationConversationWithdrawPost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/moderation/conversation/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionCreatePostRequest} apiV1ModerationOpinionCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationOpinionCreatePost: async (apiV1ModerationOpinionCreatePostRequest: ApiV1ModerationOpinionCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationOpinionCreatePostRequest' is not null or undefined
            assertParamExists('apiV1ModerationOpinionCreatePost', 'apiV1ModerationOpinionCreatePostRequest', apiV1ModerationOpinionCreatePostRequest)
            const localVarPath = `/api/v1/moderation/opinion/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationOpinionCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationOpinionGetPost: async (apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationOpinionWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ModerationOpinionGetPost', 'apiV1ModerationOpinionWithdrawPostRequest', apiV1ModerationOpinionWithdrawPostRequest)
            const localVarPath = `/api/v1/moderation/opinion/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationOpinionWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationOpinionWithdrawPost: async (apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationOpinionWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ModerationOpinionWithdrawPost', 'apiV1ModerationOpinionWithdrawPostRequest', apiV1ModerationOpinionWithdrawPostRequest)
            const localVarPath = `/api/v1/moderation/opinion/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationOpinionWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1MuteUserCreatePostRequest} apiV1MuteUserCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MuteUserCreatePost: async (apiV1MuteUserCreatePostRequest: ApiV1MuteUserCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1MuteUserCreatePostRequest' is not null or undefined
            assertParamExists('apiV1MuteUserCreatePost', 'apiV1MuteUserCreatePostRequest', apiV1MuteUserCreatePostRequest)
            const localVarPath = `/api/v1/mute/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1MuteUserCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MuteUserGetPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/mute/user/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1NotificationFetchPostRequest} [apiV1NotificationFetchPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NotificationFetchPost: async (apiV1NotificationFetchPostRequest?: ApiV1NotificationFetchPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notification/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1NotificationFetchPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NotificationMarkAllReadPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notification/mark-all-read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} auth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NotificationStreamGet: async (auth: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'auth' is not null or undefined
            assertParamExists('apiV1NotificationStreamGet', 'auth', auth)
            const localVarPath = `/api/v1/notification/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1OpinionCreatePostRequest} apiV1OpinionCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionCreatePost: async (apiV1OpinionCreatePostRequest: ApiV1OpinionCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1OpinionCreatePostRequest' is not null or undefined
            assertParamExists('apiV1OpinionCreatePost', 'apiV1OpinionCreatePostRequest', apiV1OpinionCreatePostRequest)
            const localVarPath = `/api/v1/opinion/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1OpinionCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionDeletePost: async (apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationOpinionWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1OpinionDeletePost', 'apiV1ModerationOpinionWithdrawPostRequest', apiV1ModerationOpinionWithdrawPostRequest)
            const localVarPath = `/api/v1/opinion/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationOpinionWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionFetchAnalysisByConversationPost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1OpinionFetchAnalysisByConversationPost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/opinion/fetch-analysis-by-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1OpinionFetchByConversationPostRequest} apiV1OpinionFetchByConversationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionFetchByConversationPost: async (apiV1OpinionFetchByConversationPostRequest: ApiV1OpinionFetchByConversationPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1OpinionFetchByConversationPostRequest' is not null or undefined
            assertParamExists('apiV1OpinionFetchByConversationPost', 'apiV1OpinionFetchByConversationPostRequest', apiV1OpinionFetchByConversationPostRequest)
            const localVarPath = `/api/v1/opinion/fetch-by-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1OpinionFetchByConversationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1OpinionFetchBySlugIdListPostRequest} apiV1OpinionFetchBySlugIdListPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionFetchBySlugIdListPost: async (apiV1OpinionFetchBySlugIdListPostRequest: ApiV1OpinionFetchBySlugIdListPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1OpinionFetchBySlugIdListPostRequest' is not null or undefined
            assertParamExists('apiV1OpinionFetchBySlugIdListPost', 'apiV1OpinionFetchBySlugIdListPostRequest', apiV1OpinionFetchBySlugIdListPostRequest)
            const localVarPath = `/api/v1/opinion/fetch-by-slug-id-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1OpinionFetchBySlugIdListPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1OpinionFetchHiddenByConversationPostRequest} apiV1OpinionFetchHiddenByConversationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionFetchHiddenByConversationPost: async (apiV1OpinionFetchHiddenByConversationPostRequest: ApiV1OpinionFetchHiddenByConversationPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1OpinionFetchHiddenByConversationPostRequest' is not null or undefined
            assertParamExists('apiV1OpinionFetchHiddenByConversationPost', 'apiV1OpinionFetchHiddenByConversationPostRequest', apiV1OpinionFetchHiddenByConversationPostRequest)
            const localVarPath = `/api/v1/opinion/fetch-hidden-by-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1OpinionFetchHiddenByConversationPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1PollRespondPostRequest} apiV1PollRespondPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PollRespondPost: async (apiV1PollRespondPostRequest: ApiV1PollRespondPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1PollRespondPostRequest' is not null or undefined
            assertParamExists('apiV1PollRespondPost', 'apiV1PollRespondPostRequest', apiV1PollRespondPostRequest)
            const localVarPath = `/api/v1/poll/respond`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1PollRespondPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ReportConversationCreatePostRequest} apiV1ReportConversationCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportConversationCreatePost: async (apiV1ReportConversationCreatePostRequest: ApiV1ReportConversationCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ReportConversationCreatePostRequest' is not null or undefined
            assertParamExists('apiV1ReportConversationCreatePost', 'apiV1ReportConversationCreatePostRequest', apiV1ReportConversationCreatePostRequest)
            const localVarPath = `/api/v1/report/conversation/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ReportConversationCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportConversationFetchPost: async (apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationConversationWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ReportConversationFetchPost', 'apiV1ModerationConversationWithdrawPostRequest', apiV1ModerationConversationWithdrawPostRequest)
            const localVarPath = `/api/v1/report/conversation/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationConversationWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ReportOpinionCreatePostRequest} apiV1ReportOpinionCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportOpinionCreatePost: async (apiV1ReportOpinionCreatePostRequest: ApiV1ReportOpinionCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ReportOpinionCreatePostRequest' is not null or undefined
            assertParamExists('apiV1ReportOpinionCreatePost', 'apiV1ReportOpinionCreatePostRequest', apiV1ReportOpinionCreatePostRequest)
            const localVarPath = `/api/v1/report/opinion/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ReportOpinionCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportOpinionFetchPost: async (apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1ModerationOpinionWithdrawPostRequest' is not null or undefined
            assertParamExists('apiV1ReportOpinionFetchPost', 'apiV1ModerationOpinionWithdrawPostRequest', apiV1ModerationOpinionWithdrawPostRequest)
            const localVarPath = `/api/v1/report/opinion/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1ModerationOpinionWithdrawPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1TopicFollowPostRequest} apiV1TopicFollowPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TopicFollowPost: async (apiV1TopicFollowPostRequest: ApiV1TopicFollowPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1TopicFollowPostRequest' is not null or undefined
            assertParamExists('apiV1TopicFollowPost', 'apiV1TopicFollowPostRequest', apiV1TopicFollowPostRequest)
            const localVarPath = `/api/v1/topic/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TopicFollowPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TopicGetAllTopicsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/topic/get-all-topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TopicGetFollowedPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/topic/get-followed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1TopicFollowPostRequest} apiV1TopicFollowPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TopicUnfollowPost: async (apiV1TopicFollowPostRequest: ApiV1TopicFollowPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1TopicFollowPostRequest' is not null or undefined
            assertParamExists('apiV1TopicUnfollowPost', 'apiV1TopicFollowPostRequest', apiV1TopicFollowPostRequest)
            const localVarPath = `/api/v1/topic/unfollow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TopicFollowPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserConversationFetchPostRequest} [apiV1UserConversationFetchPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserConversationFetchPost: async (apiV1UserConversationFetchPostRequest?: ApiV1UserConversationFetchPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/conversation/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserConversationFetchPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserDeletePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserLanguagePreferencesGetPostRequest} apiV1UserLanguagePreferencesGetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserLanguagePreferencesGetPost: async (apiV1UserLanguagePreferencesGetPostRequest: ApiV1UserLanguagePreferencesGetPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UserLanguagePreferencesGetPostRequest' is not null or undefined
            assertParamExists('apiV1UserLanguagePreferencesGetPost', 'apiV1UserLanguagePreferencesGetPostRequest', apiV1UserLanguagePreferencesGetPostRequest)
            const localVarPath = `/api/v1/user/language-preferences/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserLanguagePreferencesGetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserLanguagePreferencesUpdatePostRequest} [apiV1UserLanguagePreferencesUpdatePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserLanguagePreferencesUpdatePost: async (apiV1UserLanguagePreferencesUpdatePostRequest?: ApiV1UserLanguagePreferencesUpdatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/language-preferences/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserLanguagePreferencesUpdatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserOpinionFetchPostRequest} [apiV1UserOpinionFetchPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserOpinionFetchPost: async (apiV1UserOpinionFetchPostRequest?: ApiV1UserOpinionFetchPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/opinion/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserOpinionFetchPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserPollGetResponseByConversationsPost: async (requestBody?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/poll/get-response-by-conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileGetPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserUsernameUpdatePost: async (apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UserUsernameUpdatePostRequest' is not null or undefined
            assertParamExists('apiV1UserUsernameUpdatePost', 'apiV1UserUsernameUpdatePostRequest', apiV1UserUsernameUpdatePostRequest)
            const localVarPath = `/api/v1/user/username/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserUsernameUpdatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1UserVoteGetByConversationsPostRequest} apiV1UserVoteGetByConversationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserVoteGetByConversationsPost: async (apiV1UserVoteGetByConversationsPostRequest: ApiV1UserVoteGetByConversationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UserVoteGetByConversationsPostRequest' is not null or undefined
            assertParamExists('apiV1UserVoteGetByConversationsPost', 'apiV1UserVoteGetByConversationsPostRequest', apiV1UserVoteGetByConversationsPostRequest)
            const localVarPath = `/api/v1/user/vote/get-by-conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UserVoteGetByConversationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiV1VoteCastPostRequest} apiV1VoteCastPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoteCastPost: async (apiV1VoteCastPostRequest: ApiV1VoteCastPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1VoteCastPostRequest' is not null or undefined
            assertParamExists('apiV1VoteCastPost', 'apiV1VoteCastPostRequest', apiV1VoteCastPostRequest)
            const localVarPath = `/api/v1/vote/cast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1VoteCastPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccountGenerateUnusedRandomUsernamePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccountGenerateUnusedRandomUsernamePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AccountGenerateUnusedRandomUsernamePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccountIsUsernameInUsePost(apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccountIsUsernameInUsePost(apiV1UserUsernameUpdatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AccountIsUsernameInUsePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest} apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdministratorOrganizationAddUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest: ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdministratorOrganizationAddUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AdministratorOrganizationAddUserOrganizationMappingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationCreateOrganizationPostRequest} apiV1AdministratorOrganizationCreateOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdministratorOrganizationCreateOrganizationPost(apiV1AdministratorOrganizationCreateOrganizationPostRequest: ApiV1AdministratorOrganizationCreateOrganizationPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdministratorOrganizationCreateOrganizationPost(apiV1AdministratorOrganizationCreateOrganizationPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AdministratorOrganizationCreateOrganizationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationDeleteOrganizationPostRequest} apiV1AdministratorOrganizationDeleteOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdministratorOrganizationDeleteOrganizationPost(apiV1AdministratorOrganizationDeleteOrganizationPostRequest: ApiV1AdministratorOrganizationDeleteOrganizationPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdministratorOrganizationDeleteOrganizationPost(apiV1AdministratorOrganizationDeleteOrganizationPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AdministratorOrganizationDeleteOrganizationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdministratorOrganizationGetAllOrganizationsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdministratorOrganizationGetAllOrganizationsPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AdministratorOrganizationGetAllOrganizationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost(apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost(apiV1UserUsernameUpdatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest} apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AdministratorOrganizationRemoveUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest: ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AdministratorOrganizationRemoveUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AdministratorOrganizationRemoveUserOrganizationMappingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AuthAuthenticatePostRequest} apiV1AuthAuthenticatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest: ApiV1AuthAuthenticatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthAuthenticatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthAuthenticatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthCheckLoginStatusPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthCheckLoginStatusPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthCheckLoginStatusPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthCheckLoginStatusPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AuthPhoneVerifyOtpPostRequest} apiV1AuthPhoneVerifyOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthPhoneVerifyOtpPost(apiV1AuthPhoneVerifyOtpPostRequest: ApiV1AuthPhoneVerifyOtpPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthPhoneVerifyOtpPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthPhoneVerifyOtpPost(apiV1AuthPhoneVerifyOtpPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthPhoneVerifyOtpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AuthTicketVerifyPostRequest} apiV1AuthTicketVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthTicketVerifyPost(apiV1AuthTicketVerifyPostRequest: ApiV1AuthTicketVerifyPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthTicketVerifyPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthTicketVerifyPost(apiV1AuthTicketVerifyPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthTicketVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1AuthZkpGenerateVerificationLinkPostRequest} apiV1AuthZkpGenerateVerificationLinkPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthZkpGenerateVerificationLinkPost(apiV1AuthZkpGenerateVerificationLinkPostRequest: ApiV1AuthZkpGenerateVerificationLinkPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthZkpGenerateVerificationLinkPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthZkpGenerateVerificationLinkPost(apiV1AuthZkpGenerateVerificationLinkPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthZkpGenerateVerificationLinkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1AuthZkpVerifyUserStatusAndAuthenticatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationClosePost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationClosePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationClosePost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationClosePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ConversationCreatePostRequest} apiV1ConversationCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationCreatePost(apiV1ConversationCreatePostRequest: ApiV1ConversationCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationCreatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationCreatePost(apiV1ConversationCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationDeletePost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationDeletePost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ConversationExportStatusPostRequest} apiV1ConversationExportStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationExportDeletePost(apiV1ConversationExportStatusPostRequest: ApiV1ConversationExportStatusPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationExportDeletePost(apiV1ConversationExportStatusPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationExportDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationExportHistoryPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1ConversationExportHistoryPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationExportHistoryPost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationExportHistoryPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationExportReadinessPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationExportReadinessPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationExportReadinessPost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationExportReadinessPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationExportRequestPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationExportRequestPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationExportRequestPost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationExportRequestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ConversationExportStatusPostRequest} apiV1ConversationExportStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationExportStatusPost(apiV1ConversationExportStatusPostRequest: ApiV1ConversationExportStatusPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationExportStatusPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationExportStatusPost(apiV1ConversationExportStatusPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationExportStatusPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ConversationFetchRecentPostRequest} apiV1ConversationFetchRecentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationFetchRecentPost(apiV1ConversationFetchRecentPostRequest: ApiV1ConversationFetchRecentPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationFetchRecentPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationFetchRecentPost(apiV1ConversationFetchRecentPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationFetchRecentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationGetPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationGetPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationGetPost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationGetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationImportActivePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationImportActivePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationImportActivePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationImportActivePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationImportCsvPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationImportPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationImportCsvPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationImportCsvPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ConversationImportPostRequest} apiV1ConversationImportPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationImportPost(apiV1ConversationImportPostRequest: ApiV1ConversationImportPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationImportPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationImportPost(apiV1ConversationImportPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationImportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ConversationImportStatusPostRequest} apiV1ConversationImportStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationImportStatusPost(apiV1ConversationImportStatusPostRequest: ApiV1ConversationImportStatusPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationImportStatusPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationImportStatusPost(apiV1ConversationImportStatusPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationImportStatusPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationOpenPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationOpenPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationOpenPost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationOpenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConversationValidateCsvPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationValidateCsvPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ConversationValidateCsvPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ConversationValidateCsvPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationCreatePostRequest} apiV1ModerationConversationCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationConversationCreatePost(apiV1ModerationConversationCreatePostRequest: ApiV1ModerationConversationCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationConversationCreatePost(apiV1ModerationConversationCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationConversationCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationGetPostRequest} apiV1ModerationConversationGetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationConversationGetPost(apiV1ModerationConversationGetPostRequest: ApiV1ModerationConversationGetPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModeration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationConversationGetPost(apiV1ModerationConversationGetPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationConversationGetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationConversationWithdrawPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationConversationWithdrawPost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationConversationWithdrawPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionCreatePostRequest} apiV1ModerationOpinionCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationOpinionCreatePost(apiV1ModerationOpinionCreatePostRequest: ApiV1ModerationOpinionCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationOpinionCreatePost(apiV1ModerationOpinionCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationOpinionCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationOpinionGetPost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1ModerationOpinionGetPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationOpinionGetPost(apiV1ModerationOpinionWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationOpinionGetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ModerationOpinionWithdrawPost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ModerationOpinionWithdrawPost(apiV1ModerationOpinionWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ModerationOpinionWithdrawPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1MuteUserCreatePostRequest} apiV1MuteUserCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1MuteUserCreatePost(apiV1MuteUserCreatePostRequest: ApiV1MuteUserCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1MuteUserCreatePost(apiV1MuteUserCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1MuteUserCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1MuteUserGetPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1MuteUserGetPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1MuteUserGetPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1MuteUserGetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1NotificationFetchPostRequest} [apiV1NotificationFetchPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1NotificationFetchPost(apiV1NotificationFetchPostRequest?: ApiV1NotificationFetchPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1NotificationFetchPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1NotificationFetchPost(apiV1NotificationFetchPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1NotificationFetchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1NotificationMarkAllReadPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1NotificationMarkAllReadPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1NotificationMarkAllReadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} auth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1NotificationStreamGet(auth: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1NotificationStreamGet(auth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1NotificationStreamGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1OpinionCreatePostRequest} apiV1OpinionCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OpinionCreatePost(apiV1OpinionCreatePostRequest: ApiV1OpinionCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1OpinionCreatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1OpinionCreatePost(apiV1OpinionCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1OpinionCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OpinionDeletePost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1OpinionDeletePost(apiV1ModerationOpinionWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1OpinionDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OpinionFetchAnalysisByConversationPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1OpinionFetchAnalysisByConversationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1OpinionFetchAnalysisByConversationPost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1OpinionFetchAnalysisByConversationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1OpinionFetchByConversationPostRequest} apiV1OpinionFetchByConversationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OpinionFetchByConversationPost(apiV1OpinionFetchByConversationPostRequest: ApiV1OpinionFetchByConversationPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UserOpinionFetchPost200ResponseInnerOpinionItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1OpinionFetchByConversationPost(apiV1OpinionFetchByConversationPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1OpinionFetchByConversationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1OpinionFetchBySlugIdListPostRequest} apiV1OpinionFetchBySlugIdListPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OpinionFetchBySlugIdListPost(apiV1OpinionFetchBySlugIdListPostRequest: ApiV1OpinionFetchBySlugIdListPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UserOpinionFetchPost200ResponseInnerOpinionItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1OpinionFetchBySlugIdListPost(apiV1OpinionFetchBySlugIdListPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1OpinionFetchBySlugIdListPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1OpinionFetchHiddenByConversationPostRequest} apiV1OpinionFetchHiddenByConversationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1OpinionFetchHiddenByConversationPost(apiV1OpinionFetchHiddenByConversationPostRequest: ApiV1OpinionFetchHiddenByConversationPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UserOpinionFetchPost200ResponseInnerOpinionItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1OpinionFetchHiddenByConversationPost(apiV1OpinionFetchHiddenByConversationPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1OpinionFetchHiddenByConversationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1PollRespondPostRequest} apiV1PollRespondPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PollRespondPost(apiV1PollRespondPostRequest: ApiV1PollRespondPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PollRespondPost(apiV1PollRespondPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1PollRespondPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ReportConversationCreatePostRequest} apiV1ReportConversationCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ReportConversationCreatePost(apiV1ReportConversationCreatePostRequest: ApiV1ReportConversationCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ReportConversationCreatePost(apiV1ReportConversationCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ReportConversationCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ReportConversationFetchPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1ReportConversationFetchPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ReportConversationFetchPost(apiV1ModerationConversationWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ReportConversationFetchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ReportOpinionCreatePostRequest} apiV1ReportOpinionCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ReportOpinionCreatePost(apiV1ReportOpinionCreatePostRequest: ApiV1ReportOpinionCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ReportOpinionCreatePost(apiV1ReportOpinionCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ReportOpinionCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ReportOpinionFetchPost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1ReportConversationFetchPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1ReportOpinionFetchPost(apiV1ModerationOpinionWithdrawPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1ReportOpinionFetchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1TopicFollowPostRequest} apiV1TopicFollowPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TopicFollowPost(apiV1TopicFollowPostRequest: ApiV1TopicFollowPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TopicFollowPost(apiV1TopicFollowPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1TopicFollowPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TopicGetAllTopicsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1TopicGetAllTopicsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TopicGetAllTopicsPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1TopicGetAllTopicsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TopicGetFollowedPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1TopicGetFollowedPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TopicGetFollowedPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1TopicGetFollowedPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1TopicFollowPostRequest} apiV1TopicFollowPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TopicUnfollowPost(apiV1TopicFollowPostRequest: ApiV1TopicFollowPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TopicUnfollowPost(apiV1TopicFollowPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1TopicUnfollowPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserConversationFetchPostRequest} [apiV1UserConversationFetchPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserConversationFetchPost(apiV1UserConversationFetchPostRequest?: ApiV1UserConversationFetchPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1ConversationFetchRecentPost200ResponseConversationDataListInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserConversationFetchPost(apiV1UserConversationFetchPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserConversationFetchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserDeletePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserDeletePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserLanguagePreferencesGetPostRequest} apiV1UserLanguagePreferencesGetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserLanguagePreferencesGetPost(apiV1UserLanguagePreferencesGetPostRequest: ApiV1UserLanguagePreferencesGetPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UserLanguagePreferencesGetPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserLanguagePreferencesGetPost(apiV1UserLanguagePreferencesGetPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserLanguagePreferencesGetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserLanguagePreferencesUpdatePostRequest} [apiV1UserLanguagePreferencesUpdatePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserLanguagePreferencesUpdatePost(apiV1UserLanguagePreferencesUpdatePostRequest?: ApiV1UserLanguagePreferencesUpdatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserLanguagePreferencesUpdatePost(apiV1UserLanguagePreferencesUpdatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserLanguagePreferencesUpdatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserOpinionFetchPostRequest} [apiV1UserOpinionFetchPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserOpinionFetchPost(apiV1UserOpinionFetchPostRequest?: ApiV1UserOpinionFetchPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UserOpinionFetchPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserOpinionFetchPost(apiV1UserOpinionFetchPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserOpinionFetchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserPollGetResponseByConversationsPost(requestBody?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UserPollGetResponseByConversationsPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserPollGetResponseByConversationsPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserPollGetResponseByConversationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileGetPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UserProfileGetPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileGetPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserProfileGetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserUsernameUpdatePost(apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserUsernameUpdatePost(apiV1UserUsernameUpdatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserUsernameUpdatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1UserVoteGetByConversationsPostRequest} apiV1UserVoteGetByConversationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserVoteGetByConversationsPost(apiV1UserVoteGetByConversationsPostRequest: ApiV1UserVoteGetByConversationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1UserVoteGetByConversationsPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserVoteGetByConversationsPost(apiV1UserVoteGetByConversationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1UserVoteGetByConversationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiV1VoteCastPostRequest} apiV1VoteCastPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1VoteCastPost(apiV1VoteCastPostRequest: ApiV1VoteCastPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1VoteCastPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1VoteCastPost(apiV1VoteCastPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiV1VoteCastPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountGenerateUnusedRandomUsernamePost(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.apiV1AccountGenerateUnusedRandomUsernamePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountIsUsernameInUsePost(apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.apiV1AccountIsUsernameInUsePost(apiV1UserUsernameUpdatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest} apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationAddUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest: ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1AdministratorOrganizationAddUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationCreateOrganizationPostRequest} apiV1AdministratorOrganizationCreateOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationCreateOrganizationPost(apiV1AdministratorOrganizationCreateOrganizationPostRequest: ApiV1AdministratorOrganizationCreateOrganizationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1AdministratorOrganizationCreateOrganizationPost(apiV1AdministratorOrganizationCreateOrganizationPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationDeleteOrganizationPostRequest} apiV1AdministratorOrganizationDeleteOrganizationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationDeleteOrganizationPost(apiV1AdministratorOrganizationDeleteOrganizationPostRequest: ApiV1AdministratorOrganizationDeleteOrganizationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1AdministratorOrganizationDeleteOrganizationPost(apiV1AdministratorOrganizationDeleteOrganizationPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationGetAllOrganizationsPost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost200Response> {
            return localVarFp.apiV1AdministratorOrganizationGetAllOrganizationsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost(apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost200Response> {
            return localVarFp.apiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost(apiV1UserUsernameUpdatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest} apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AdministratorOrganizationRemoveUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest: ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1AdministratorOrganizationRemoveUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AuthAuthenticatePostRequest} apiV1AuthAuthenticatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest: ApiV1AuthAuthenticatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1AuthAuthenticatePost200Response> {
            return localVarFp.apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthCheckLoginStatusPost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1AuthCheckLoginStatusPost200Response> {
            return localVarFp.apiV1AuthCheckLoginStatusPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1AuthLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AuthPhoneVerifyOtpPostRequest} apiV1AuthPhoneVerifyOtpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthPhoneVerifyOtpPost(apiV1AuthPhoneVerifyOtpPostRequest: ApiV1AuthPhoneVerifyOtpPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1AuthPhoneVerifyOtpPost200Response> {
            return localVarFp.apiV1AuthPhoneVerifyOtpPost(apiV1AuthPhoneVerifyOtpPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AuthTicketVerifyPostRequest} apiV1AuthTicketVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthTicketVerifyPost(apiV1AuthTicketVerifyPostRequest: ApiV1AuthTicketVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1AuthTicketVerifyPost200Response> {
            return localVarFp.apiV1AuthTicketVerifyPost(apiV1AuthTicketVerifyPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1AuthZkpGenerateVerificationLinkPostRequest} apiV1AuthZkpGenerateVerificationLinkPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthZkpGenerateVerificationLinkPost(apiV1AuthZkpGenerateVerificationLinkPostRequest: ApiV1AuthZkpGenerateVerificationLinkPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1AuthZkpGenerateVerificationLinkPost200Response> {
            return localVarFp.apiV1AuthZkpGenerateVerificationLinkPost(apiV1AuthZkpGenerateVerificationLinkPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1AuthZkpVerifyUserStatusAndAuthenticatePost200Response> {
            return localVarFp.apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationClosePost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationClosePost200Response> {
            return localVarFp.apiV1ConversationClosePost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ConversationCreatePostRequest} apiV1ConversationCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationCreatePost(apiV1ConversationCreatePostRequest: ApiV1ConversationCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationCreatePost200Response> {
            return localVarFp.apiV1ConversationCreatePost(apiV1ConversationCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationDeletePost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1ConversationDeletePost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ConversationExportStatusPostRequest} apiV1ConversationExportStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportDeletePost(apiV1ConversationExportStatusPostRequest: ApiV1ConversationExportStatusPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1ConversationExportDeletePost(apiV1ConversationExportStatusPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportHistoryPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1ConversationExportHistoryPost200ResponseInner>> {
            return localVarFp.apiV1ConversationExportHistoryPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportReadinessPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationExportReadinessPost200Response> {
            return localVarFp.apiV1ConversationExportReadinessPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportRequestPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationExportRequestPost200Response> {
            return localVarFp.apiV1ConversationExportRequestPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ConversationExportStatusPostRequest} apiV1ConversationExportStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationExportStatusPost(apiV1ConversationExportStatusPostRequest: ApiV1ConversationExportStatusPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationExportStatusPost200Response> {
            return localVarFp.apiV1ConversationExportStatusPost(apiV1ConversationExportStatusPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ConversationFetchRecentPostRequest} apiV1ConversationFetchRecentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationFetchRecentPost(apiV1ConversationFetchRecentPostRequest: ApiV1ConversationFetchRecentPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationFetchRecentPost200Response> {
            return localVarFp.apiV1ConversationFetchRecentPost(apiV1ConversationFetchRecentPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationGetPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationGetPost200Response> {
            return localVarFp.apiV1ConversationGetPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationImportActivePost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationImportActivePost200Response> {
            return localVarFp.apiV1ConversationImportActivePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationImportCsvPost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationImportPost200Response> {
            return localVarFp.apiV1ConversationImportCsvPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ConversationImportPostRequest} apiV1ConversationImportPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationImportPost(apiV1ConversationImportPostRequest: ApiV1ConversationImportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationImportPost200Response> {
            return localVarFp.apiV1ConversationImportPost(apiV1ConversationImportPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ConversationImportStatusPostRequest} apiV1ConversationImportStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationImportStatusPost(apiV1ConversationImportStatusPostRequest: ApiV1ConversationImportStatusPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationImportStatusPost200Response> {
            return localVarFp.apiV1ConversationImportStatusPost(apiV1ConversationImportStatusPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationOpenPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationOpenPost200Response> {
            return localVarFp.apiV1ConversationOpenPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConversationValidateCsvPost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationValidateCsvPost200Response> {
            return localVarFp.apiV1ConversationValidateCsvPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationCreatePostRequest} apiV1ModerationConversationCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationConversationCreatePost(apiV1ModerationConversationCreatePostRequest: ApiV1ModerationConversationCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1ModerationConversationCreatePost(apiV1ModerationConversationCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationGetPostRequest} apiV1ModerationConversationGetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationConversationGetPost(apiV1ModerationConversationGetPostRequest: ApiV1ModerationConversationGetPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ConversationFetchRecentPost200ResponseConversationDataListInnerMetadataModeration> {
            return localVarFp.apiV1ModerationConversationGetPost(apiV1ModerationConversationGetPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationConversationWithdrawPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1ModerationConversationWithdrawPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionCreatePostRequest} apiV1ModerationOpinionCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationOpinionCreatePost(apiV1ModerationOpinionCreatePostRequest: ApiV1ModerationOpinionCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1ModerationOpinionCreatePost(apiV1ModerationOpinionCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationOpinionGetPost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1ModerationOpinionGetPost200Response> {
            return localVarFp.apiV1ModerationOpinionGetPost(apiV1ModerationOpinionWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ModerationOpinionWithdrawPost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1ModerationOpinionWithdrawPost(apiV1ModerationOpinionWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1MuteUserCreatePostRequest} apiV1MuteUserCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MuteUserCreatePost(apiV1MuteUserCreatePostRequest: ApiV1MuteUserCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1MuteUserCreatePost(apiV1MuteUserCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1MuteUserGetPost(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1MuteUserGetPost200ResponseInner>> {
            return localVarFp.apiV1MuteUserGetPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1NotificationFetchPostRequest} [apiV1NotificationFetchPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NotificationFetchPost(apiV1NotificationFetchPostRequest?: ApiV1NotificationFetchPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1NotificationFetchPost200Response> {
            return localVarFp.apiV1NotificationFetchPost(apiV1NotificationFetchPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NotificationMarkAllReadPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1NotificationMarkAllReadPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} auth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NotificationStreamGet(auth: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1NotificationStreamGet(auth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1OpinionCreatePostRequest} apiV1OpinionCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionCreatePost(apiV1OpinionCreatePostRequest: ApiV1OpinionCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1OpinionCreatePost200Response> {
            return localVarFp.apiV1OpinionCreatePost(apiV1OpinionCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionDeletePost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1OpinionDeletePost(apiV1ModerationOpinionWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionFetchAnalysisByConversationPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1OpinionFetchAnalysisByConversationPost200Response> {
            return localVarFp.apiV1OpinionFetchAnalysisByConversationPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1OpinionFetchByConversationPostRequest} apiV1OpinionFetchByConversationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionFetchByConversationPost(apiV1OpinionFetchByConversationPostRequest: ApiV1OpinionFetchByConversationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1UserOpinionFetchPost200ResponseInnerOpinionItem>> {
            return localVarFp.apiV1OpinionFetchByConversationPost(apiV1OpinionFetchByConversationPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1OpinionFetchBySlugIdListPostRequest} apiV1OpinionFetchBySlugIdListPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionFetchBySlugIdListPost(apiV1OpinionFetchBySlugIdListPostRequest: ApiV1OpinionFetchBySlugIdListPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1UserOpinionFetchPost200ResponseInnerOpinionItem>> {
            return localVarFp.apiV1OpinionFetchBySlugIdListPost(apiV1OpinionFetchBySlugIdListPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1OpinionFetchHiddenByConversationPostRequest} apiV1OpinionFetchHiddenByConversationPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1OpinionFetchHiddenByConversationPost(apiV1OpinionFetchHiddenByConversationPostRequest: ApiV1OpinionFetchHiddenByConversationPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1UserOpinionFetchPost200ResponseInnerOpinionItem>> {
            return localVarFp.apiV1OpinionFetchHiddenByConversationPost(apiV1OpinionFetchHiddenByConversationPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1PollRespondPostRequest} apiV1PollRespondPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PollRespondPost(apiV1PollRespondPostRequest: ApiV1PollRespondPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1PollRespondPost(apiV1PollRespondPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ReportConversationCreatePostRequest} apiV1ReportConversationCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportConversationCreatePost(apiV1ReportConversationCreatePostRequest: ApiV1ReportConversationCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1ReportConversationCreatePost(apiV1ReportConversationCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportConversationFetchPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1ReportConversationFetchPost200ResponseInner>> {
            return localVarFp.apiV1ReportConversationFetchPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ReportOpinionCreatePostRequest} apiV1ReportOpinionCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportOpinionCreatePost(apiV1ReportOpinionCreatePostRequest: ApiV1ReportOpinionCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1ReportOpinionCreatePost(apiV1ReportOpinionCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ReportOpinionFetchPost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1ReportConversationFetchPost200ResponseInner>> {
            return localVarFp.apiV1ReportOpinionFetchPost(apiV1ModerationOpinionWithdrawPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1TopicFollowPostRequest} apiV1TopicFollowPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TopicFollowPost(apiV1TopicFollowPostRequest: ApiV1TopicFollowPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1TopicFollowPost(apiV1TopicFollowPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TopicGetAllTopicsPost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1TopicGetAllTopicsPost200Response> {
            return localVarFp.apiV1TopicGetAllTopicsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TopicGetFollowedPost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1TopicGetFollowedPost200Response> {
            return localVarFp.apiV1TopicGetFollowedPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1TopicFollowPostRequest} apiV1TopicFollowPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TopicUnfollowPost(apiV1TopicFollowPostRequest: ApiV1TopicFollowPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1TopicUnfollowPost(apiV1TopicFollowPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserConversationFetchPostRequest} [apiV1UserConversationFetchPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserConversationFetchPost(apiV1UserConversationFetchPostRequest?: ApiV1UserConversationFetchPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1ConversationFetchRecentPost200ResponseConversationDataListInner>> {
            return localVarFp.apiV1UserConversationFetchPost(apiV1UserConversationFetchPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserDeletePost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1UserDeletePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserLanguagePreferencesGetPostRequest} apiV1UserLanguagePreferencesGetPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserLanguagePreferencesGetPost(apiV1UserLanguagePreferencesGetPostRequest: ApiV1UserLanguagePreferencesGetPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UserLanguagePreferencesGetPost200Response> {
            return localVarFp.apiV1UserLanguagePreferencesGetPost(apiV1UserLanguagePreferencesGetPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserLanguagePreferencesUpdatePostRequest} [apiV1UserLanguagePreferencesUpdatePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserLanguagePreferencesUpdatePost(apiV1UserLanguagePreferencesUpdatePostRequest?: ApiV1UserLanguagePreferencesUpdatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1UserLanguagePreferencesUpdatePost(apiV1UserLanguagePreferencesUpdatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserOpinionFetchPostRequest} [apiV1UserOpinionFetchPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserOpinionFetchPost(apiV1UserOpinionFetchPostRequest?: ApiV1UserOpinionFetchPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1UserOpinionFetchPost200ResponseInner>> {
            return localVarFp.apiV1UserOpinionFetchPost(apiV1UserOpinionFetchPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserPollGetResponseByConversationsPost(requestBody?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1UserPollGetResponseByConversationsPost200ResponseInner>> {
            return localVarFp.apiV1UserPollGetResponseByConversationsPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileGetPost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UserProfileGetPost200Response> {
            return localVarFp.apiV1UserProfileGetPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserUsernameUpdatePost(apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1UserUsernameUpdatePost(apiV1UserUsernameUpdatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1UserVoteGetByConversationsPostRequest} apiV1UserVoteGetByConversationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserVoteGetByConversationsPost(apiV1UserVoteGetByConversationsPostRequest: ApiV1UserVoteGetByConversationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1UserVoteGetByConversationsPost200ResponseInner>> {
            return localVarFp.apiV1UserVoteGetByConversationsPost(apiV1UserVoteGetByConversationsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiV1VoteCastPostRequest} apiV1VoteCastPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1VoteCastPost(apiV1VoteCastPostRequest: ApiV1VoteCastPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1VoteCastPost200Response> {
            return localVarFp.apiV1VoteCastPost(apiV1VoteCastPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AccountGenerateUnusedRandomUsernamePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AccountGenerateUnusedRandomUsernamePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AccountIsUsernameInUsePost(apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AccountIsUsernameInUsePost(apiV1UserUsernameUpdatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest} apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AdministratorOrganizationAddUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest: ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AdministratorOrganizationAddUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AdministratorOrganizationCreateOrganizationPostRequest} apiV1AdministratorOrganizationCreateOrganizationPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AdministratorOrganizationCreateOrganizationPost(apiV1AdministratorOrganizationCreateOrganizationPostRequest: ApiV1AdministratorOrganizationCreateOrganizationPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AdministratorOrganizationCreateOrganizationPost(apiV1AdministratorOrganizationCreateOrganizationPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AdministratorOrganizationDeleteOrganizationPostRequest} apiV1AdministratorOrganizationDeleteOrganizationPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AdministratorOrganizationDeleteOrganizationPost(apiV1AdministratorOrganizationDeleteOrganizationPostRequest: ApiV1AdministratorOrganizationDeleteOrganizationPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AdministratorOrganizationDeleteOrganizationPost(apiV1AdministratorOrganizationDeleteOrganizationPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AdministratorOrganizationGetAllOrganizationsPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AdministratorOrganizationGetAllOrganizationsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost(apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AdministratorOrganizationGetOrganizationNamesByUsernamePost(apiV1UserUsernameUpdatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest} apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AdministratorOrganizationRemoveUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest: ApiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AdministratorOrganizationRemoveUserOrganizationMappingPost(apiV1AdministratorOrganizationAddUserOrganizationMappingPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AuthAuthenticatePostRequest} apiV1AuthAuthenticatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest: ApiV1AuthAuthenticatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthAuthenticatePost(apiV1AuthAuthenticatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AuthCheckLoginStatusPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthCheckLoginStatusPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AuthLogoutPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AuthPhoneVerifyOtpPostRequest} apiV1AuthPhoneVerifyOtpPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AuthPhoneVerifyOtpPost(apiV1AuthPhoneVerifyOtpPostRequest: ApiV1AuthPhoneVerifyOtpPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthPhoneVerifyOtpPost(apiV1AuthPhoneVerifyOtpPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AuthTicketVerifyPostRequest} apiV1AuthTicketVerifyPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AuthTicketVerifyPost(apiV1AuthTicketVerifyPostRequest: ApiV1AuthTicketVerifyPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthTicketVerifyPost(apiV1AuthTicketVerifyPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1AuthZkpGenerateVerificationLinkPostRequest} apiV1AuthZkpGenerateVerificationLinkPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AuthZkpGenerateVerificationLinkPost(apiV1AuthZkpGenerateVerificationLinkPostRequest: ApiV1AuthZkpGenerateVerificationLinkPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthZkpGenerateVerificationLinkPost(apiV1AuthZkpGenerateVerificationLinkPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1AuthZkpVerifyUserStatusAndAuthenticatePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationClosePost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationClosePost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ConversationCreatePostRequest} apiV1ConversationCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationCreatePost(apiV1ConversationCreatePostRequest: ApiV1ConversationCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationCreatePost(apiV1ConversationCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationDeletePost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationDeletePost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ConversationExportStatusPostRequest} apiV1ConversationExportStatusPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationExportDeletePost(apiV1ConversationExportStatusPostRequest: ApiV1ConversationExportStatusPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationExportDeletePost(apiV1ConversationExportStatusPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationExportHistoryPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationExportHistoryPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationExportReadinessPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationExportReadinessPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationExportRequestPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationExportRequestPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ConversationExportStatusPostRequest} apiV1ConversationExportStatusPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationExportStatusPost(apiV1ConversationExportStatusPostRequest: ApiV1ConversationExportStatusPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationExportStatusPost(apiV1ConversationExportStatusPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ConversationFetchRecentPostRequest} apiV1ConversationFetchRecentPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationFetchRecentPost(apiV1ConversationFetchRecentPostRequest: ApiV1ConversationFetchRecentPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationFetchRecentPost(apiV1ConversationFetchRecentPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationGetPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationGetPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationImportActivePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationImportActivePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationImportCsvPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationImportCsvPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ConversationImportPostRequest} apiV1ConversationImportPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationImportPost(apiV1ConversationImportPostRequest: ApiV1ConversationImportPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationImportPost(apiV1ConversationImportPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ConversationImportStatusPostRequest} apiV1ConversationImportStatusPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationImportStatusPost(apiV1ConversationImportStatusPostRequest: ApiV1ConversationImportStatusPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationImportStatusPost(apiV1ConversationImportStatusPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationOpenPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationOpenPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ConversationValidateCsvPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ConversationValidateCsvPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationCreatePostRequest} apiV1ModerationConversationCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ModerationConversationCreatePost(apiV1ModerationConversationCreatePostRequest: ApiV1ModerationConversationCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationConversationCreatePost(apiV1ModerationConversationCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationGetPostRequest} apiV1ModerationConversationGetPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ModerationConversationGetPost(apiV1ModerationConversationGetPostRequest: ApiV1ModerationConversationGetPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationConversationGetPost(apiV1ModerationConversationGetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ModerationConversationWithdrawPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationConversationWithdrawPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationOpinionCreatePostRequest} apiV1ModerationOpinionCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ModerationOpinionCreatePost(apiV1ModerationOpinionCreatePostRequest: ApiV1ModerationOpinionCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationOpinionCreatePost(apiV1ModerationOpinionCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ModerationOpinionGetPost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationOpinionGetPost(apiV1ModerationOpinionWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ModerationOpinionWithdrawPost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ModerationOpinionWithdrawPost(apiV1ModerationOpinionWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1MuteUserCreatePostRequest} apiV1MuteUserCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1MuteUserCreatePost(apiV1MuteUserCreatePostRequest: ApiV1MuteUserCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1MuteUserCreatePost(apiV1MuteUserCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1MuteUserGetPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1MuteUserGetPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1NotificationFetchPostRequest} [apiV1NotificationFetchPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1NotificationFetchPost(apiV1NotificationFetchPostRequest?: ApiV1NotificationFetchPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1NotificationFetchPost(apiV1NotificationFetchPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1NotificationMarkAllReadPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1NotificationMarkAllReadPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} auth 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1NotificationStreamGet(auth: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1NotificationStreamGet(auth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1OpinionCreatePostRequest} apiV1OpinionCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1OpinionCreatePost(apiV1OpinionCreatePostRequest: ApiV1OpinionCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1OpinionCreatePost(apiV1OpinionCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1OpinionDeletePost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1OpinionDeletePost(apiV1ModerationOpinionWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1OpinionFetchAnalysisByConversationPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1OpinionFetchAnalysisByConversationPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1OpinionFetchByConversationPostRequest} apiV1OpinionFetchByConversationPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1OpinionFetchByConversationPost(apiV1OpinionFetchByConversationPostRequest: ApiV1OpinionFetchByConversationPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1OpinionFetchByConversationPost(apiV1OpinionFetchByConversationPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1OpinionFetchBySlugIdListPostRequest} apiV1OpinionFetchBySlugIdListPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1OpinionFetchBySlugIdListPost(apiV1OpinionFetchBySlugIdListPostRequest: ApiV1OpinionFetchBySlugIdListPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1OpinionFetchBySlugIdListPost(apiV1OpinionFetchBySlugIdListPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1OpinionFetchHiddenByConversationPostRequest} apiV1OpinionFetchHiddenByConversationPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1OpinionFetchHiddenByConversationPost(apiV1OpinionFetchHiddenByConversationPostRequest: ApiV1OpinionFetchHiddenByConversationPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1OpinionFetchHiddenByConversationPost(apiV1OpinionFetchHiddenByConversationPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1PollRespondPostRequest} apiV1PollRespondPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1PollRespondPost(apiV1PollRespondPostRequest: ApiV1PollRespondPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1PollRespondPost(apiV1PollRespondPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ReportConversationCreatePostRequest} apiV1ReportConversationCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ReportConversationCreatePost(apiV1ReportConversationCreatePostRequest: ApiV1ReportConversationCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ReportConversationCreatePost(apiV1ReportConversationCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationConversationWithdrawPostRequest} apiV1ModerationConversationWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ReportConversationFetchPost(apiV1ModerationConversationWithdrawPostRequest: ApiV1ModerationConversationWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ReportConversationFetchPost(apiV1ModerationConversationWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ReportOpinionCreatePostRequest} apiV1ReportOpinionCreatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ReportOpinionCreatePost(apiV1ReportOpinionCreatePostRequest: ApiV1ReportOpinionCreatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ReportOpinionCreatePost(apiV1ReportOpinionCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1ModerationOpinionWithdrawPostRequest} apiV1ModerationOpinionWithdrawPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1ReportOpinionFetchPost(apiV1ModerationOpinionWithdrawPostRequest: ApiV1ModerationOpinionWithdrawPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1ReportOpinionFetchPost(apiV1ModerationOpinionWithdrawPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1TopicFollowPostRequest} apiV1TopicFollowPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1TopicFollowPost(apiV1TopicFollowPostRequest: ApiV1TopicFollowPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1TopicFollowPost(apiV1TopicFollowPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1TopicGetAllTopicsPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1TopicGetAllTopicsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1TopicGetFollowedPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1TopicGetFollowedPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1TopicFollowPostRequest} apiV1TopicFollowPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1TopicUnfollowPost(apiV1TopicFollowPostRequest: ApiV1TopicFollowPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1TopicUnfollowPost(apiV1TopicFollowPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserConversationFetchPostRequest} [apiV1UserConversationFetchPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1UserConversationFetchPost(apiV1UserConversationFetchPostRequest?: ApiV1UserConversationFetchPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserConversationFetchPost(apiV1UserConversationFetchPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1UserDeletePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserDeletePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserLanguagePreferencesGetPostRequest} apiV1UserLanguagePreferencesGetPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1UserLanguagePreferencesGetPost(apiV1UserLanguagePreferencesGetPostRequest: ApiV1UserLanguagePreferencesGetPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserLanguagePreferencesGetPost(apiV1UserLanguagePreferencesGetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserLanguagePreferencesUpdatePostRequest} [apiV1UserLanguagePreferencesUpdatePostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1UserLanguagePreferencesUpdatePost(apiV1UserLanguagePreferencesUpdatePostRequest?: ApiV1UserLanguagePreferencesUpdatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserLanguagePreferencesUpdatePost(apiV1UserLanguagePreferencesUpdatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserOpinionFetchPostRequest} [apiV1UserOpinionFetchPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1UserOpinionFetchPost(apiV1UserOpinionFetchPostRequest?: ApiV1UserOpinionFetchPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserOpinionFetchPost(apiV1UserOpinionFetchPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1UserPollGetResponseByConversationsPost(requestBody?: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserPollGetResponseByConversationsPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1UserProfileGetPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserProfileGetPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserUsernameUpdatePostRequest} apiV1UserUsernameUpdatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1UserUsernameUpdatePost(apiV1UserUsernameUpdatePostRequest: ApiV1UserUsernameUpdatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserUsernameUpdatePost(apiV1UserUsernameUpdatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1UserVoteGetByConversationsPostRequest} apiV1UserVoteGetByConversationsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1UserVoteGetByConversationsPost(apiV1UserVoteGetByConversationsPostRequest: ApiV1UserVoteGetByConversationsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1UserVoteGetByConversationsPost(apiV1UserVoteGetByConversationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiV1VoteCastPostRequest} apiV1VoteCastPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apiV1VoteCastPost(apiV1VoteCastPostRequest: ApiV1VoteCastPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1VoteCastPost(apiV1VoteCastPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



